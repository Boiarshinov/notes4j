---
title: "Processes"
tags:
  - linux
draft: false
---

# Processes

__Процесс__ - это экземпляр запущенного приложения / команды. 
Углубляясь, это абстракция ОС, включающая в себя все ресурсы, над которыми производится работа, и потоки исполнения.

__Поток__ (thread) - это выполнение на процессоре набора инструкций.
Потоки делят между собой время процессора, благодаря чему можно исполнять сразу несколько приложений одновременно.
Строго говоря, приложения работают не одновременно, так как процессор постоянно переключается с одной задачи на другую, но из-за большой частоты переключения человеку (и не только) кажется, что они работают одновременно.

Потоки одного процесса используют общий контекст, то есть могут обращаться к одним и тем же областям памяти, зарезервированных под процесс.
Поэтому для масштабирования лучше увеличить количество потоков в процессе, нежели чем запускать дополнительный процесс.

Поток операционной системы потребляет приблизительно 1 МБ памяти.


## Процессы

Каждый запущенный процесс имеет свой собственный идентификатор __PID__ - process id.
Этот идентификатор присваивается при запуске процесса.
Если процесс перезапустить, то идентификатор у него может поменяться.

Также у каждого процесса есть процесс-родитель, из которого был запущен этот процесс.
Ссылка на процесс-родитель записывается в идентификатор __PPID__ - parent process id.
Самый первый процесс, который является предком для всех остальных процессов (как дракула для всех вампиров), запускается операционной системой при старте.

### Демоны

Демон - это процесс, работающий в фоновом режиме.
К демонам относятся утилиты, например, слушающие внешние устройства.
Или например процессы, оркестрирующие другие процессы: dockerd, systemd.

Существует рекомендация в название процесса-демона добавлять суффикс 'd': dockerd, httpd.
Но многие демоны не пользуются этой рекомендацией.

У демонов всегда родительский процесс `PPID = 1`


### Работа с процессами

Посмотреть список всех активных процессов можно с помощью команды `ps`:
```bash
❯ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.5  0.2  33816  8084 ?        Ss   00:11   3:56 /sbin/init splash
root        62  0.0  0.0      0     0 ?        S    00:11   0:00 [watchdogd]
root       367  0.0  0.3  67216 12736 ?        Ssl  00:11   0:19 /usr/lib/udisks2/udisksd
systemd+  1814  0.0  0.0   6068  1852 ?        S    00:12   0:00 nginx: worker process
arty     17848  0.0  0.0   9788  2524 pts/0    R+   12:47   0:00 ps aux
```
Процессы, у которых команда указана в квадратных скобках - это часть ядра ОС.

Еще одна команда, позволяющая вывести список процессов, и к тому же изучить их наследование, это `pstree`:
```bash
❯ pstree -p
systemd(1)─┬─alsactl(392)
           ├─avahi-daemon(378)───avahi-daemon(408)
           ├─bluetoothd(719)
```

Зачастую необходимо найти PID какого-нибудь запущенного процесса, для этого можно использовать `grep`:
```bash
❯ ps aux | grep nginx
root      1406  0.0  0.1   5916  4036 ?        Ss   00:12   0:00 nginx: master process nginx -g daemon off;
systemd+  1814  0.0  0.0   6068  1852 ?        S    00:12   0:00 nginx: worker process
pi       25191  0.0  0.0   7348   564 pts/0    S+   13:04   0:00 grep --color=auto nginx
```

То же самое можно сделать с помощью специальной команды `pgrep`:
```bash
❯ pgrep -a nginx
1406 nginx: master process nginx -g daemon off;
1814 nginx: worker process
```

Каждому процессу соответствует своя директория в [системной директории](./file_system.md) `/proc/`.
В этой директории можно найти ссылку на исполняемый файл:
```bash
❯ sudo ls -l /proc/1814/exe
lrwxrwxrwx 1 systemd-network systemd-journal 0 May 19 13:39 /proc/1814/exe -> /usr/sbin/nginx
```

### Завершение процесса

Чтобы поставить процесс на паузу или завершить его, необходимо отправить ему [сигнал](./signals.md), например с помощью команды `kill`:
```bash
kill -15 1814
```

Иногда вы знаете название процесса, который необходимо остановить, но не знаете его PID. 
Тогда приходится сначала узнавать PID с помощью `pgrep`, а потом только вызывать kill, рискуя опечататься.
Это неудобно.
Для таких случаев есть команды `killall` и `pkill`.

`killall` останавливает все процессы с переданным наименованием:
```bash
killall -9 nginx
```

`pkill` останавливает все процессы, названия которых соответствуют шаблону:
```bash
pkill -9 ngin
```


### Зомби-процессы

В некоторых случаях процесс может доделать свою полезную работу, но при этом не завершаться, так как он ожидает отмашки от своего родительского процесса.
Такие полудохлые процессы называются __зомби__.
Наличие зомби-процессов совершенно нормально, если они быстро исчезают.

Зомби-процессы, не занимают памяти, но занимают место в таблице процессов.
Другими словами они блокируют идентификатор PID, который мог бы быть передан другому процессу.

Зомби процессы невозможно остановить с помощью [сигналов](./signals.md).

Зомби процессы могут возникать и висеть бесконечно из-за ошибок в программе.
Когда их станет слишком много, таблица процессов исчерпается и будет невозможно создать никакой новый процесс.
В таком случае требуется вмешательство администратора, например, перезагрузка системы.


---
## К изучению
- [ ] [Хабр. Процессы и потоки](https://habr.com/ru/post/40227/)
- [X] Про [зомби-процессы на Wikipedia](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81-%D0%B7%D0%BE%D0%BC%D0%B1%D0%B8)
