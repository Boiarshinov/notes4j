---
title: "Bash scripts"
tags:
  - linux
draft: false
---

# Bash scripts

Файлы скриптов имеют расширение `.sh`.
В начале файла нужно указать какой оболочкой должен выполняться скрипт:
```sh
#!/bin/bash
```

Далее можно использовать те же команды, которые мы использовали в терминале.

Каждая новая команда в скрипте должна записываться с новой строчки. Либо можно записывать команды в одну строку, но разделять их между собой точкой с запятой.

## Переменные

Объявление переменных происходит, как и во многих других ЯП, но между именем переменной и ее значением не должно быть пробелов:
```sh
greeting="Hello world"
```

Также переменным можно присваивать вывод каких-либо программ, для этого необходимо обернуть программу косыми кавычками:
```sh
fromEcho=`echo "test"`
```

Доступ к значению переменной осуществляется через ссылки а-ля Expression Language в Java:
```sh
echo "${greeting}, Artem!"
```

Можно и не использовать фигурные скобки, если после имени переменной не нужно дописывать символы.


## Ключевые слова

- `exit <код возврата>` - завершает выполнение скрипта. Если не указывать код, то по умолчанию он будет равен 0 - корректное завершение.
- `read` - записывает в переменную/ые введенные пользователем значения
    - `-p <сообщение>` - позволяет вывести сообщение, предлагающее ввести пользователю значения
```sh
var="null"
echo ""
read -p "Введите значение: " var
echo "Вы ввели ${var}"
```

### Комментарии
```sh
#Комментарий
```

## Аргументы
Внутри скрипта можно получать значения переданных аргументов:

- `$<число от 1>` - значение аргумента с указанным номером
- `$0` - имя скрипта
- `$#` - количество аргументов
- `$?` - возвращает код возврата последней выполненной программы
- `$@` - массив всех аргументов

Если в скрипт передано меньше аргументов чем нужно, то вместо отсутствующий аргументов скрипт будет оперировать пустыми строками.


## Управляющие конструкции

- Условный оператор
```sh
if [[ <условие> ]]
then
    # действия в случае истинности
else #необязательный элемент
    # действия в случае ложности
fi
```
Можно использовать и одинарные скобки, но тогда придется эскейпить различные символы.
Например: `if [ 1 \< 2] ...`.
Без слэша в одинарных скобках Bash интерпретировал бы знак `<` как пайп-оператор и выполнение бы закончилось синтаксической ошибкой.

Еще есть вариант с подстановкой вместо условия результата работы программы:
```sh
if `<программа>`
then
    # действия в случае корректного завершения
else #необязательный элемент
    # действия в случае ошибок
fi
```

Также могут быть составлены цепочки проверок с помощью оператора `elif`:
```sh
if [[ <условие> ]]
then
    # действия
elif [[ <еще условие> ]]
then
    # действия
else
    # действия
fi
```

- switch-case
```sh
case ${<переменная>} in
<значение>)
    #действия
    ;;
<значение>)
    #действия
    ;;
*)
    #дефолт
```


## Логические операторы
Строковые логические операторы:
- `-z <строка>` - строка пуста
- `-n <строка>` - строка не пуста
- `==` - строки равны
- `!=` - строки не равны
- `<` - меньше (сравнение лексикографическое)
- `>` - больше

Числовые логические операторы:
- `-eq` - (equals) равно
- `-ne` - (not equals) не равно
- `-lt` - (lesser then) меньше
- `-le` - меньше или равно
- `-gt` - (greater then) больше
- `-ge` - больше или равно

Условные операторы для путей:
- `-e <путь>` - (exist) путь существует
- `-f <путь>` - (file) это файл
- `-d <путь>` - (directory) это директория
- `-s <путь>` - размер файла больше 0
- `-x <путь>` - файл исполняемый

Условия:
- `!` - отрицание
- `&&` - логическое И
- `||` - логическое ИЛИ

Логические выражения можно разделять с помощью скобок:
```sh
if [[ ($# -lt 2 || $1 == "Vovan loh") && -e $1 ]]
```

---
## Циклы
### Цикл `for`

В цикле for указывается не условие выхода из цикла, а список значений, для которых будут выполняться действия. 
Значения разделяются между собой с помощью пробелов
```sh
for <переменная> in <список значений>
do
    #действия
done
```

В цикле также можно использовать знакомые по Java ключевые слова:
- `break` - прерывает цикл
- `continue` - досрочно заканчивает итерацию цикла

### Цикл `while`
В цикле `while` уже указывается условие:
```sh
while [[ <условие> ]]
do
    #действия
done
```


## Арифметические операторы
Операторы:
- `+`, `-`, `*`, `/` - стандартные арифметические
- `%` - остаток от деления
- `**` - возведение в степень

Записываются арифметические выражения с помощью ключевого слова `let` в двойных кавычках:
```sh
a=10
b=3
let "c = a / b"
let "d = a % b"
let "e = a ** b"
```

Вместо let может использоваться синтаксис:
```sh
c=$[a+b]
c=$((a + b))
```

Также поддерживается сокращенная запись:
- `+=`


## Функции
Функции обычно объявляются на самом верху программы, иначе скрипт их не найдет.
Функции записываются с помощью следующего синтаксиса:
```sh
function my_function()
{
    #действия (можно пользоваться аргументами $1, $2 и т.д.)
}
```

В коде функции вызываются по своему имени:
```sh
...
my_function "$arg1" "$arg2"
...
```

Внутри функции можно создавать локальные и глобальные переменные. Локальные переменные создаются с помощью ключевого слова local:
```sh
local <var_name>
```

---
## Работа с опциями
В консольных приложениях зачастую есть возможность кастомизации с помощью передаваемых ключей.
Обработку ключей можно выполнять с помощью команды `getopts`.
Например, для скрипта, имеющего ключи `-h`, `-u`, `-p`, `-e`, обработка будет выглядеть так:
```sh
username=""
pass=""
env=""

while getopts 'hu:p:e:' option; do
    case $option in
    h) echo "help declaration"
      exit 0
      ;;
    u) username="$OPTARG"
      ;;
    p) pass="$OPTARG"
      ;;
    e) env="$OPTARG"
      ;;
    *) exit 1
    esac
done
```

---
## К изучению:

- [X] [Курс на Stepic](https://stepik.org/lesson/6281/step/1?unit=1233)
- [ ] [Ссылки в bash](https://stackoverflow.com/questions/5163144/what-are-the-special-dollar-sign-shell-variables)