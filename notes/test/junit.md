---
title: "JUnit"
tags:
  - test
  - external_lib
draft: false
---

Что такое юнит-тестирование тут: [Юнит-тестирование (модульное тестирование)](evernote:///view/170585988/s440/60c8a759-cccd-4e8f-bc98-ee72172c2d9a/60c8a759-cccd-4e8f-bc98-ee72172c2d9a/)

## Связь версий Java и JUnit

| JUnit | Java |
| --- | --- |
| JUnit 3 | Java 1.4 |
| JUnit 4 | Java 5 |
| Junit 5 | Java 8 |

Это значит, что версия JUnit не сможет работать с кодом, который использует более раннюю JDK, чем указано.

Принципы построения тестов значительно отличаются от версии к версии.

### JUnit 5

JUnit 5 состоит из следующих модулей:

- **JUnit Platform** - Основная часть платформы JUnit
- **JUnit Jupiter** - Движок для прогонки тестов, написанных на JUnit 5. Сюда входят все аннотации
- **JUnit Vintage** - Движок для прогонки тестов, написанных на более ранних версиях JUnit

Для использования тестового фреймворка нужно добавить в свой проект эти зависимости. JUnit Jupiter транзитивно подтянет JUnit Platform.

---
## Наименования

### Устаревшая парадигма

Обычно каждому классу соответствует свой тестирующий класс. Название тестирующего класса обычно заканчивается на *Test.

Названия методов обычно дублируют названия методов тестируемого класса с приставкой `test*()` в начале, но в принципе название может быть любым.

Пример:
```java
class MyClass{
    public static double calculateDeadDate(){
        ...
    }
}

class MyClassTest{
    @Test
    public void testCalculateDeadDate(){
        ...
    }
}
```

Такой стиль наименования появился из-за того, что первоначально тестовые фреймворки не умели отличать тестовые классы и методы от обычного кода при помощи аннотаций (потому что их тогда не было), поэтому названия классов и методов парсились с помощью регулярок, чтобы найти тесты в кодовой базе.

### Современная парадигма

Более современной системой наименования является именование тестовых классов все так же по названию основного класса с добавлением суффикса Test, а тестовые методы именуются в соответствии с тестовым кейсом.

Например, для метода, получающего на вход две даты и определяющего какая из них является более ранней, названия тестов могут быть следующими: `takeSameDatesAndReturnAnyOfThem`, `takeTwoDatesAndReturnEarlierOfThem`, `takeNullAndThrowException`.

---
## Тестовые методы

Для того чтобы дать понять JUnit, какие методы являются тестовыми, над ними ставится одна из следующих аннотаций:

### Обычный тест

`@Test` - обычный тест, который будет исполнен единожды.

### Параметризованный тест

Параметризованным тестам посвящена отдельная заметка: [JUnit. Параметризованные тесты](junit_parameterized_test.md)

### Повторяющийся тест

`@RepeatedTest` - тест будет выполнен указанное количество раз. Обычно такой тип тестов используется, когда обнаруживается, что результат какого-то тестового метода является плавающим, и тест не проходит через раз (такое бывает, когда тестовые данные генерируются рандомом). Выставив достаточно большое количество повторений можно определить при каких входных данных тест падает

### Фабрика тестов

`@TestFactory` -

### Тестовые шаблоны

Тестовые шаблоны - это заготовки для тестов. Они нужны, чтобы задать правила многократного вызова с возможностью изменения входных параметров. Частными примерами тестовых шаблонов являются `@RepeatedTest` и `@ParameterizedTest`.

---
## Жизненный цикл тестового класса

По умолчанию перед прогонкой каждого тестового метода создается новый объект тестового класса.

Изменить это поведение можно, указав политику создания объектов тестового класса в аннотации `@TestInstance`. При этом можно задать следующие варианты политик:

- `PER_METHOD` - для каждого тестового метода создается новый объект класса. Является поведением по умолчанию.
- `PER_CLASS` - создается один объект класса для всех тестовых методов.

Для того чтобы задать жизненный цикл тестового класса, используются методы, над которыми проставляются следующие аннотации:

- `@BeforeAll` - перед прогонкой всех тестов один раз выполнится этот метод. Обычно используется для подготовки каких-либо данных для теста (например, поднятие тест-контейнера). Метод должен быть static void.
- `@BeforeEach` - метод будет выполнен перед прогонкой каждого тестового метода. Обычно используется для подготовки моков. Метод должен быть void.
- `@AfterAll` - после прогонки все тестов данного класса исполнится этот метод. Используется для освобождения ресурсов. Метод должен быть static void.
- `@AfterEach` - метод будет выполнен после прогонки каждого тестового метода. Обычно используется для того, чтобы очистить какие-то общие ресурсы. Метод должен быть void.

Тест можно выключить с помощью аннотации `@Disabled`. Обычно это делается, когда в срочном порядке изменяется функционал и на переработку тестов нет времени.

Также существуют аннотации, включающие / отключающие тест при выполнении некоторого условия, например:

- `@EnabledOnOs` - включает тест только для определенной операционной системы
- `@DisabledOnJre` - отключает тест для указанной версии Java
- `@DisabledIf` - отключает тест при выполнении указанного условия. В аннотацию передается название метода, возвращающего boolean.

* * *

## Документирование тестов

Бывает, что названия тестового метода недостаточно, чтобы описать тест-кейс. В таких случаях можно использовать аннотацию `@DisplayName`, которая позволяет описать тест-кейс с помощью обычной строки:

```java
@DisplayName("Проверка перевода денежных средств в обычном случае")
@Test
void atNormalCase() {
    /** */
}
```

Название тест-кейса из `@DisplayName` будет использоваться в отчетах тестирования и будет отображаться в панели мониторинга при ручном запуске тестов из IDE.

### Генераторы названий

Существует возможность задать собственные правила видоизменения названий тест-кейсов. Делается это с помощью генератора, который необходимо указать в аннотации `@DisplayNameGeneration`:

```java
@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
public class MyTest {

    //В отчетах название тестового метода будет отображаться с пробелами вместо нижних подчеркиваний
    @Test
    void datetime_convert_to_date_correctly() { /** */ }
}
```

Существует несколько стандартных генераторов:

- `Standard` - Генератор, используемый по умолчанию
- `Simple` - Удаляет из названия скобки у тех методов, у которых нет параметров
- `ReplaceUnderscores` - заменяет нижние подчеркивания на пробелы
- `IndicativeSentences` - образует название тест-кейса из названия класса и названия метода

Если возможностей стандартных генераторов не хватает, можно написать свой собственный

В параметризованных тестах можно задать уточняющее наименование тест-кейса с помощью атрибута `name` и синтаксиса шаблонов, подобного slf4j:

```java
@DisplayName("Check that for all inputs testing object generates prime values")
@ParametrizedTest(name = "Create prime value from input {0}")
@ValueSource({0, 1, 5, 100})
void primeValuesGenerator() /** */
```

---
## Проверка результатов

Проверка результатов исполнения тестируемых методов проводится с помощью утверждений. Если утверждение не выполняется, то тест падает с ошибкой.

Тест выполняется до первого неверного утверждения.
Запись утверждений может проводиться с помощью

- Стандартная библиотека утверждений (ассертов)
- Сторонние библиотеки утверждений (ассертов)

### Стандартная библиотека утверждений

Стандартные утверждения находятся в классе `Assertions` и являются статическими методами:

- `assertEquals()` - сравнивает ожидаемое значение с действительным
- `assertFalse()` - проверяет, что логическая переменная ложна
- `assertTrue()` - проверяет, что логическая переменная истинна
- `assertNull()` - проверка на null
- `assertNonNull()` - проверка на не null
- `assertThrows()` - проверка, что при исполнении метода будет выброшено указанное исключение
- `assertTimeout()` - проверяет, что переданная лямбда будет выполнена в указанный таймаут

Во все утверждения последним аргументом может передаваться строка, которая будет дополнительно выводиться при падении теста.

Есть комбинированные утверждения `assertAll()`, в состав которых может быть включено несколько утверждений в виде лямбд. В данном случае будут проверены все утверждения и по ним будет собран итоговый отчет. Такой вид утверждений хорош, когда требуется проконтролировать совпадение множества полей.

```java
assertAll("lolkek",
    () -> assertEquals(expectedResult.getName(), actualResult.getName())
    () -> assertEquals(expectedResult.getId(), actualResult.getId())
)
```

### Сторонние библиотеки утверждений

Когда не хватает функциональности стандартной библиотеки, можно использовать сторонние. Например:

- AssertJ
- Hamcrest
- Truth

### Предположения

Предположения - это почти то же самое, что утверждения, но вместо того чтобы фейлить тест, ложные предположения заставляют тестовый движок считать тест проигнорированным.

Обычно предположения используются в тех случаях, когда прогонка теста не имеет смысла при определенных условиях. Такими условиями может быть: операционная система, параметры системы, параметры JVM и проч.

Все предположения находятся в классе `Assumptions` и представлены статическими методами:

- `assumeTrue()` - проверяет, что указанное условие выполняется

<mark>//Дописать, там же еще куча методов</mark>

* * *

## Вложенные классы

Когда тестов в одном классе становится слишком много, в них становится тяжело ориентироваться. Для того чтобы сгруппировать тесты можно использовать вложенные классы. Такие классы должны быть нестатическими и должны быть помечены аннотацией `@Nested`.

```java
public class LocalDateTest {
    @Nested
    class LocalDateCreationTest {
        @Test void createByEpochDay() { /* */ }
        @Test void createByParsing() { /* */ }
    }

    @Nested
    class LocalDateBeforeTest {
        @Test void plusDaysPositive() { /* */ }
        @Test void plusDaysNegative() { /* */ }
    }
}
```

---
## Внедрение зависимостей

JUnit 5 в отличие от предыдущих версий поддерживает внедрение зависимостей.

В стандартной конфигурации возможно внедрение в тестовые классы / методы трех зависимостей:

- `TestInfo` - позволяет получить данные о данном тестовом методе в рантайме. Для внедрения нужно просто передать его в тестовый метод одним из аргументов.
- `RepetitionInfo` - внедряется в повторяющиеся тесты и позволяет в рантайме узнать номер текущего повторения.
- `TestReporter` - используется для вывода в лог / консоль информации. Должен использоваться вместо стандартного вывода в консоль или логирования.

Для того чтобы подключить другие виды внедрения зависимостей необходимо подключать дополнительные модули с помощью аннотации `@ExtendWith`. 
Часто используемыми модулями являются `SpringExtension` и `MockitoExtension`.

---
## Тэги

Тесты можно помечать с помощью тэгов, группируя их тем самым по различным признакам. Теги являются обычными строками.

При прогонке тестов можно выбирать тесты с какими тегами запускать, а с какими игнорировать.

Это может быть полезно при наличии долго исполняющихся тестов. Например, можно разделить юниты, компонентные и интеграционные тесты и прогонять их отдельно, уменьшая таймаут обратной связи.

Тесты помечаются тэгами с помощью аннотации `@Tag`, в которую передается строка с названием группы:

```java
@Tag("integration")
@Test
void bigAndSlowTest() {/* */}
```

По мне так тэги - это какая-то хрень. Во-первых, названия тегов задаются с помощью строковыми литералами, в которых можно допустить ошибку, в итоге тест не попадет в нужную группу. Во-вторых, запуск тестов с определенными тегами не слишком очевиден в Intellij IDEA, а указание определенных групп тестирования плохо реализовано в maven-конфигурации.

---
## Параллельный запуск

По умолчанию тесты запускаются последовательно в одном потоке.

Параллельный запуск является экспериментальной фичей и может работать не очень стабильно.

Параллельное выполнение тестов может нести в себе опасность при наличии общих ресурсов. Это может приводить к отказам тестов из-за состояния гонки или по таймауту при дедлоках.

Для того чтобы настроить параллельный запуск тестов нужно в файле `junit-platform.properties` указать следующие настройки:

```properties
# Включает возможность параллельного выполнения
junit.jupiter.execution.parallel.enabled = true

# Тестовые методы одного класса будут запускаться последовательно в одном потоке
junit.jupiter.execution.parallel.mode.default = same_thread

# Тесты в разных тестовых классах будут запускаться параллельно
junit.jupiter.execution.parallel.mode.classes.default = concurrent

# Количество потоков будет пропорционально количеству свободных ядер процессора
junit.jupiter.execution.parallel.config.strategy = dynamic
```

Для того чтобы переопределить дефолтное поведение для определенного тестового класса, нужно повесить над ним аннотацию `@Execution`, в которой установить способ запуска с помощью аргумента:

- `SAME_THREAD`
- `CONCURRENT`

Это может быть полезным для того, чтобы юнит-тесты выполнялись параллельно, а тесты, использующие базу данных (или другие общие ресурсы) - только последовательно.

### Блокировка

Можно задавать блокировку каких-либо ресурсов с помощью аннотации `@ResourceLock`. Ресурс указывается в виде строковой константы.

В таком случае тесты, использующие один и тот же ресурс будут запускаться только последовательно.

---
## Конфигурация

Задать определенное поведение тестового фреймворка можно с помощью:

- Задания настроек в build-скриптах (Gradle или Maven)
- Файла `junit-platform.properties`, лежащего в classpath.

<mark>//Написать про настройки</mark>

---
## Подключение зависимости

Для включения JUnit в проект необходимо в [Maven](../build/maven.md)добавить следующую зависимость:

```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <version>${junit.version}</version>
    <scope>test</scope>
</dependency>
```
Раньше требовалось указывать большое количество зависимостей, но потом в junit появилась агрегирующая зависимость.

Строчка `<scope>test</scope>` указывает Maven, что зависимость нужна только при исполнении тестов.

---
## К изучению

- [X] Официальная документация на JUnit 5: https://junit.org/junit5/docs/current/user-guide/
- [X] Азы:  http://javastudy.ru/junit/junit-hello-world/
- [X] Описание JUnit 3 и JUnit 4 и их различий: https://habr.com/ru/post/120101/
- [ ] Как тестировать приватные методы: https://www.artima.com/suiterunner/private.html
- [ ] Неплохой сайт по основам с примерами: https://easyjava.ru/category/testing/junit/