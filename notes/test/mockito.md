---
title: "Mockito"
tags:
  - test
  - external_lib
draft: false
---

**Mockito** - библиотека, предназначенная для упрощения тестирования кода.

Обычно Mockito используется совместно с тестирующими библиотеками вроде [JUnit](junit.md).

*Mock* (мок) - это объект, который подменяет какой-то настоящий объект, но при этом вызовы всех его методов возвращают null, false, 0, пустые коллекции.

*Stub* (заглушка) - это мок, в котором захардкожено, что должны возвращать методы при их вызове.

*Spy* (шпион) - объект, который создается на основе реального класса, реализует весь его функционал, но при этом некоторые его методы могут быть заглушены.

Зачастую при тестировании методов класса, его экземпляр делают шпионом, чтобы протестировать вызовы его внутренних методов. Если эти методы были приватными, то частенько приходится делать их package-private, чтобы иметь возможность протестировать и не увеличивать размер одного тестового метода до монструозного.

---
## Класс Mockito

Вся основная функциональность Mockito заключена в статических методах этого класса:

- `static <T> T mock(Class<T>)` - создает мок-объект указанного класса
- `static <T> T spy(Class<T>)` - создает шпиона указанного класса. У класса должен быть пустой конструктор.
- `static <T> T spy(T)` - создает шпиона на основе существующего объекта
- `static OngoingStubbing when(mock.method(args))` - перехватывает вызов метода данного класса с указанными аргументами. Используется в связке с методами семейства `then` (см. класс `OngoingStubbing`) и методами семейства `do`.
- `static MockingDetails mockingDetails(Object)` - при передаче любого объекта метод возвращает информацию, является ли данный объект моком, спаем или обычным объектом
- Методы семейства `do`: (применяются для методов, возвращающих void, и для шпионов)
    - `static Stubber doReturn(Object)` - задает возвращаемое значение при вызове метода мока
```java
Mockito.doReturn("Vovan - loh").when(mock).myMethod(args);
```
-
    - `static Stubber doThrow(Throwable)` -
    - `static Stubber doAnswer(Answer)` -
    - `static Stubber doNothing()` - переопределяет метод мока так, что тот ничего не делает и ничего не возвращает.
- Методы для определения аргументов методов:
    - `static <T> T any()` - метод будет заглушен при вызове с любым аргументом.
    - `static <T> T eq(T)` - метод будет заглушен при вызове с аргументом, равным переданному.
    - `static <T> T same(T)` - метод будет заглушен при вызове с аргументом, ссылающимся на тот же объект.

```java
Mockito.when(mock.myMethod(Mockito.any())).thenReturn("bla");
```
-
    - `static <T> T argThat(ArgumentMatcher<T>)` - метод будет заглушен при вызове с аргументом, удовлетворяющим заданному условию. Зачастую вместо матчера используется лямбда-выражение.
- Методы, проверяющие факт вызова других методов:
    - `static <T> T verify(T mock)` - тест считается проваленным, если метод указанного мока не был вызван, или был вызван более 1 раза.
    - `static <T> T verify(T mock, VerificationMode)` - расширяет условие предыдущего метода.
        - `times(int)` - количество раз.
        - `never()` - никогда.
        - `atLeastOnce()` - хотя бы один раз.
        - `atLeast(int)` - хотя бы указанное количество раз.
        - `atMost(int)` - не более указанного количества раз.
    - `static void verifyNoMoreInteractions(mock)` - тест считается проваленным, если с моком были совершены какие-либо действия. Вместо данного метода лучше использовать `verivy(mock, never())`.
    - `static void verifyZeroInteractions(mock)` - полный аналог предыдущего метода.
    - `static InOrder inOrder(mock)` - возвращает объект, который позволяет контролировать последовательность вызова методов с помощью `verify()`.
- `static void clearInvocations(mocks...)` - сбрасывает счетчики вызовов методов указанных моков.
- `static void reset(mocks...)` - возвращает поведение методов к дефолтному. Вызывается перед или после тестирования какого-либо метода (актуально для TestNG).

---
## Заглушки на вызовы методов

С помощью Mockito можно создавать заглушки для методов на мокированных объектах.

Для этого необходимо указать мокируемый
```java
MyClass importantField = Mockito.mock(MyClass.class);
Mockito.when(importantField.myMethod()).thenReturn("returned from stub!");
```

Для методов, возвращающих void и для шпионов необходимо сначала вызывать `doNothing()` / `doReturn()` и только потом `when()`:

```java
MyClass importantField = Mockito.spy(MyClass.class);
Mockito.doReturn("returned from stub!").when(importantField).myMethod();
```

---
## Проверка вызова метода

Проверка вызова осуществляется с помощью метода `verify()` (см. выше). В результате вызова метода будет возвращен мокированный объект, из которого нужно дернуть нужный метод.
```java
Mockito.verify(this.mock).myLovelyMethod(args);
```

---
## Аннотации

- `@Mock` - ставится на объектах, которые будут мокировать поля тестируемого класса.
- `@Spy` - ставится на экземпляре тестируемого класса, если нужно сделать из него шпиона.
- `@Captor` - создает экземпляры ArgumentCaptor
- `@InjectMocks` -

---
## Класс OngoingStubbing

Объекты данного класса возвращаются при создании заглушек на методах мока. Для шпионов такой способ на подходит - нужно использовать

Все методы класса семейства then возвращают объекты того же класса, что позволяет установить различное поведение при повторных вызовах заглушенного метода мокированного объекта.

Методы:

- `OngoingStubbing<T> thenReturn(T)` - указывает что должен вернуть перехваченный метод.
- `OngoingStubbing<T> thenReturn(T, T...)` - задает возвращаемое значение и возвращаемые значения при последующих вызовах.
- `OngoingStubbing<T> thenThrow(Throwable...)` - задает исключение, которое будет выброшено при вызове метода.
- `OngoingStubbing<T> thenAnswer(Answer)` - задает поведение, которое будет выполняться при вызове метода.
- `OngoingStubbing<T> then(Answer)` - аналог предыдущего метода.

---
## Интерфейс `Answer<T>`

Answer является функциональным интерфейсом, в котором определен всего один метод:

- `T answer(InvocationOnMock)` - определяет возвращаемое значение в зависимости от условий вызова.

Объект InvocationOnMock позволяет получить данные об условиях вызова метода: значениях аргументов

Чаще всего вместо явной реализации интерфейса используется лямбда-выражение.
```java
Mockito.when(dataService.getDataByIds(Mockito.any()))
    .thenAnswer(invocation -> invocation
        .<List<String>>getArgument(0).stream()
        .map(id -> {
            switch (id) {
                case "a": return "dataItemA";
                case "b": return "dataItemB";
                default: return null;
            }
        })
        .collect(Collectors.toList()
    )
);
```

Чаще всего методы `thenAnswer()` и `doAnswer()` используются тогда, когда хочется передать код, а не состояние.

---
## Перехват аргументов методов

Иногда необходимо перехватить аргументы замокированного метода, вызываемого в середине или в конце тестируемого метода, чтобы убедиться, что данные для этого метода были подготовлены корректно.

В этом случае используется `ArgumentCaptor`.

Экземпляр `ArgumentCaptor` обычно создается как поле в классе-тесте и инициализируется с помощью аннотации `@Captor`:

```java
@Captor
private ArgumentCaptor<Collection<User>> captor;
```

Перехват производится при проверке вызова метода с помощью метода `capture()`:
```java
Mockito.verify(this.usersRepository).saveAndFlush(this.captor.capture());
```

После чего можно получить данные, пришедшие в виде аргумента в метод с помощью метода `getValue()`.

---
## Класс MockingDetails

Конструкторы:

- Объекты данного класса получаются путем вызова статического метода `Mockito.mockingDetails()` с объектом, о котором мы хотим узнать побольше, в качестве аргумента.

Класс позволяет вытащить информацию из мока с помощью следующих методов:

- `boolean isMock()` - сообщает, является ли объект моком.
- `boolean isSpy()` - сообщает, является ли объект шпионом.
- `Collection<Stubbings> getStubbings()` - возвращает коллекцию заглушек.

---
## Подключение зависимости

Для использования Mockito в своем проекте, необходимо добавить в pom.xml:
```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>${mockito-version}</version>
    <scope>test</scope>
</dependency>
```

---
## Чего не хватает в Mockito

В Mockito не хватает возможности создания заглушек не для самих методов, а для абстракций, которые эти методы могут поставлять.

Хотелось бы, чтобы были добавлены методы со следующими сигнатурами:

- `OngoingStubbing when(Supplier<T>)` - создает заглушку для метода, переданного с помощью лямбда-выражения.
- `OngoingStubbing when(Runnable)` - то же, но для void методов.
- `T verify(Supplier<T>)` - проверяет вызов метода на мокированном объекте
- `verify(Runnable)` - проверяет вызов метода на мокированном объекте

---
## К изучению

- [X] Официальный сайт: https://site.mockito.org/
- [ ] Javadoc. Разработчики считают, что нет лучшей документации, чем код и поэтому всю документацию пишут исключительно в виде javadoc.
- [ ] Wiki по Mockito (хорошие статьи общего назначения, но плохо рассказано как пользоваться библиотекой): https://github.com/mockito/mockito/wiki
- [X] Хорошая статья с полным обзором: https://habr.com/ru/post/444982/
- [X] Примеры использования Mockito (так себе): https://habr.com/ru/post/243155/