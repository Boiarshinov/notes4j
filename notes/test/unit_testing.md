---
title: "Юнит-тестирование (модульное тестирование)"
tags:
  - test
draft: false
---

Юнит-тестирование - тестирование отдельных частей ПО по отдельности. Тесты обычно пишутся для каждой нетривиальной функции или метода.

Цель юнит-тестирования - изолировать отдельные части программы и показать, что по отдельности они работоспособны.


---
## Школы тестирования

Существует две школы с разным подходом к юнит-тестам: классическая и лондонская.

**Лондонская школа** считает, что юнит - это класс, и что все зависимости класса должны быть замокированы в тесте.
Благодаря всеобщему мокированию тесты могут с поразительной точностью обнаруживать места, в которые закралась ошибка.
Написание тестов в духе лондонской школы ведет к хрупкости тестов - они начинают падать при любом рефакторинге, включающем изменение зависимостей класса.
Именно в стиле лондонской школы были написаны тесты в проекте EOM.

**Классическая школа** считает, что юнит - это единица поведения. 
Соответственно мокируются только разделяемые зависимости.
При разработке по методике TDD получаются как правило тесты классической школы.


---
## Структура теста

### AAA
Структура теста обычно подчиняется правилу **AAA - arrange, act, assert**:

- Подготовка входных данных, подготовка эталонных данных
- Вызов тестирующего метода
- Проверка результата работы метода с эталонными данными

```java
@Test
public void complementOf() {
  //arrange
  final EnumSet<ProfileType> onlyStaff = EnumSet.of(ProfileType.ADMIN, ProfileType.MODERATOR);

  //act
  final EnumSet<ProfileType> onlyClients = EnumSet.complementOf(onlyStaff);

  //assert
  assertEquals(onlyClients.size(), 2);
  assertTrue(onlyClients.contains(ProfileType.GUEST));
  assertTrue(onlyClients.contains(ProfileType.USER));
}
```

### Given-When-Then
Есть еще один вариант структуры тестов: **Given-When-Then** - когда при указанном состоянии системы и определенных входных данных (Given) произойдет какое-либо событие (When) ожидается переход системы в другое состояние и/или происхождение новых событий (Then).

Структура почти полностью повторяет AAA, но легче воспринимается людьми далекими от программирования.


---
## Моки и стабы

При юнит-тестировании необходимо изолировать тестируемый код от внешних зависимостей, таких как база данных, внешние сервисы, файловая система и пр.
Для этих целей применяются моки и стабы.
- **Stab** - тестовая реализация интерфейса, способная отдавать данные при вызове методов, но не отслеживающая какие методы
- **Mock** - тестовая реализация интерфейса, отслеживающая то, какие действия были с ней произведены: какие методы вызваны и с какими аргументами.

Моки применяются для того, чтобы подменить зависимости, вызов которых ведет к сайд-эффектам.
Стабы применяются в тех случаях, когда вызываемый метод является чистой функцией, либо только отдает данные.

Существует разновидность мока, называемая **Spy**.
Spy являются полноценными реализациями зависимости (в отличие от моков), при этом они отслеживают вызовы методов.


---
## Библиотеки для юнит-тестирования

Тесты могут представлять собой обычные классы с методами `main`. 
Запускать такие тесты придется самостоятельно.
Но как правило для юнит-тестов существуют специальные библиотеки, управляющие их жизненным циклом.
Один из самых популярных фреймворков - xUnit, где вместо 'x' подставляется идентификатор языка.

Java:
- [JUnit](junit.md) - наиболее популярная библиотека с большим количеством плагинов
- TestNG
- Spock (написан на Groovy, но может использоваться для тестирования Java кода)

C#:
- xUnit


---
## К изучению

- [X] Книга "Принципы юнит-тестирования" В. Хориков - 2021 г.
- [X] Хабр. [Анатомия юнит-тестов](https://habr.com/ru/post/554808/) (конспект части книги Хорикова) - 2021 г.
- [X] [Семинар от Немчинского](https://www.youtube.com/watch?v=KAny2OSYY3Y) (50 мин.)
