---
title: "Lombok"
tags:
  - external_lib
draft: false
---

**Lombok** - библиотека для Java, которая генерирует стандартный код (геттеры, сеттеры и проч.) для классов перед их компиляцией. Указание что нужно генерировать, а что нет проводятся с помощью аннотаций.

![](https://cdn2.hubspot.net/hubfs/4008838/lombok-java-supported.png)

---
## Kotlin-style

По аналогии с Kotlin, чтобы не писать тип переменной при ее объявлении, были добавлены ключевые слова:

- `var` - для объявления переменной, которая может изменять ссылку. При изменении тип объекта должен оставаться, таким же, каким был ранее.
- `val` - для объявления финальной переменной. Работает только для локальных переменных, для полей - нет.

---
## Основные аннотации

- *Генерация конструкторов*:
    - `@NoArgsConstructor` - генерирует конструктор без параметров.
    - `@RequiredArgsConstructor` - генерирует конструктор, включающий все нестатические final поля, которые еще не проинициализированы, в качестве аргументов.
    - `@AllArgsConstructor` - генерирует конструктор со всеми нестатическими полями в качестве аргументов.

Также можно задать генерацию объектов класса с помощью фабричного метода. В таком случае созданный конструктор будет приватным и будет вызываться из сгенерированного статического метода с выбранным именем:

```java
@RequiredArgsConstructor(staticName = "of")
//будет сгенерирован фабричный метод с именем "of", принимающий все нестатические финальные поля.
```

- `@Getter` - создает для поля геттер
- `@Setter` - создает для поля сеттер
- `@ToString` - создает для класса метод *toString*(), который формирует строковое представление на основе названия класса, всех его нестатических полей
- `@EqualsAndHashCode` - генерирует методы *equals*() и *hashcode*() на основе нестатических полей класса.
- `@NonNull` - если вместо объекта в метод приходит null, то выбрасывается NullPointerException. При необходимости можно поменять вид выбрасываемого исключения на IllegalArgumentException.
    - для аргумента метода или конструктора: генерирует проверку на null в начале метода.
    - для поля - при генерации конструктора с помощью аннотаций Lombok для поля будет включена проверка на null.
- `@Cleanup` - Создает блок try-with-resources, в который помещает весь текущий блок кода, строчку, над которой проставлена аннотация заключает в скобки try-with-resources (т.е. ресурс будет закрыт при выходе из блока). Используется для AutoClosable ресурсов, чтобы не загрязнять код блоками try-with-resources.

```java
public static void main(String[] args) throws IOException {
    @Cleanup InputStream in = new FileInputStream(args[0]);
    @Cleanup OutputStream out = new FileOutputStream(args[1]);
    byte[] b = new byte[10000];
    while (true) {
        int r = in.read(b);
        if (r == -1) break;
        out.write(b, 0, r);
    }
}
```

- `@Builder` - реализует паттерн Строитель. (нужно изучать подробнее)
- `@With` - аннотация используется для того, чтобы создать сеттер для поля, который будет возвращать новый экземпляр класса, идентичный текущему, кроме измененного поля. Для поля с именем "fieldName" аннотация создаст метод с именем "withFieldName()". Используется для Immutable классов. Для корректной работы аннотации, необходимо, чтобы в классе был конструктор со всеми параметрами.
- `@Getter(lazy=true)` - используется для инициализации приватных полей класса, которые должны проделать трудоемкую работу при первом вызове данного метода. Таким полем может быть к примеру кэш (хотя это нарушает SRP).
- *Логирующие аннотации* - создают поле с именем log, с реализацией логгера в зависимости от имени аннотации. Аннотация проставляется над именем класса.
    - `@CommonsLog` - реализация Apache Commons Logging
    - `@Log` - реализация [JUL - java.util.logging](../java/java_util_logging.md);
    - `@Log4j` - реализация log4j
    - `@Slf4j` - релизация slf4j
- `@Synchronized` - создает внутри метода синхронизированный блок, блокирующийся по специально созданному полю.

Также существуют экспериментальные аннотации, которые дают дополнительный функционал. Но здесь я не буду их освещать, т.к. они могут измениться к моменту их включения в стандартную версию.

---
## Комбинированные аннотации:

- `@Data` - генерирует конструктор, геттеры и сеттеры для всех полей, методы `toString()`, `equals()` и `hashcode`()`. Другими словами эта аннотация объединяет в себе аннотации: `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`, `@RequiredArgsConstructor`. Данная аннотация отлично подходит для POJO-классов.
- `@Value` - **immutable** аналог аннотации `@Data`. Все поля становятся приватными и финальными, для них генерируются геттеры (а сеттеры - нет). Сам класс также становится финализированным. Также данная аннотация объединяет в себе: `@ToString`, `@EqualsAndHashCode`, `@AllArgsConstructor`.

---
## Подробнее об аннотациях

<mark>//Самый пустой раздел. Должен дополняться одновременно с тем, как я узнаю что-то новенькое</mark>

### `@EqualsAndHashCode`

Генерирует методы `equals()` и `hashcode()` на основе нестатических полей класса.

Данную аннотацию можно кастомизировать таким образом, чтобы не включать в генерацию данных методов какие-либо поля.

Делается это с помощью параметров, передаваемых в аннотацию:

- `String[] exlude` - поля, которые необходимо игнорировать при генерации методов.
- `String[] of ` - поля, которые необходимо брать в расчет при генерации методов.

```java
@EqualsAndHashCode(exlude = {"myField"})
public class MyClass {
    private final String myField;
    private final int num;
}
```

---
## Уровни доступа

Для многих аннотаций, генерирующих методы и конструкторы, можно указать уровень доступа. Делается это с помощью перечисления AccessLevel, которое входит в состав Lombok. Уровень доступа указывается в скобках после аннотации:
```java
@With(level = AccessLevel.PROTECTED) private final String name;
```

---
## Подключение зависимости

В зависимости pom.xml добавляется еще одна dependency:
```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>${lombok-version}</version>
</dependency>
```

---
## Интеграция Lombok с Intellij IDEA

Для того чтобы среда разработки понимала, что отсутствующие методы будут сгенерированы Lombok необходимо установить плагин. Делается это как обычно.

В версии 2020.3.2 Intellij IDEA включила ломбоковский плагин в список предустановленных.

---
## К изучению:

- [X] Официальная документация по Lombok: https://projectlombok.org/features/all
- [X] GitHub проекта: https://github.com/rzwitserloot/lombok
- [ ] Перевод документации: https://urvanov.ru/2015/09/22/project-lombok/
- [X] Lombok для самых маленьких: https://javarush.ru/groups/posts/518-annotacii-chastjh-vtoraja-lombok
- [X] Шпаргалка по аннотациям Lombok на русском (неполная, по сути плохой перевод официальной документации): https://habr.com/ru/post/345520/
- [X] Lombok make Java great again (статья не годится для первого знакомства с Lombok): https://habr.com/ru/post/438870/
- [ ] На английском с примерами: https://www.baeldung.com/intro-to-project-lombok