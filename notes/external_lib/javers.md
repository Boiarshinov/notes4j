---
title: "Javers"
tags:
  - external_lib
draft: false
---

Javers - это библиотека для определения различий между различными версиями одной сущности. Также она позволяет сохранять информацию о различиях между версиями сущности в базу данных.

![JaVers logo](https://javers.org/img/logotype.svg?timestamp=1592758106)

---
# Определение различий

Для определения различий достаточно создать объект типа `Javers` и вызвать у него метод `compare()`.

Создать объект `Javers` можно с помощью построителя:
```java
Javers comparator = JaversBuilder.javers().build();
```

В метод `compare()` передается старая и новая версия сущности:
```java
Diff comparison = comparator.compare(oldVersion, newVersion);
```

В результате получаем объект класса `Diff`, который содержит все отличия между версиями сущности.

При сравнении полей объекта Javers различает между собой Entity, Value Object и Value.

- **Entity** - это сущность у которой существует первичный ключ, индивидуализирующий данную сущность.
- **Value Object** - это объекты, у которых нет собственного идентификатора, и они представляют собой просто свалку различных значений.
- **Value** - это объекты, в кишки которых Javers не полезет и будет сравнивать поля такого типа с помощью метода `equals()`.
- Внутренние типы Javers:
    - **Primitive** -
    - **Container** -

По умолчанию Javers сравнивает два объекта, как Value Object.

Когда Javers сравнивает между собой коллекции, он определяет тип обобщения коллекции с помощью рефлексии.

## Настойка модели

### Определение Entity

Для того чтобы пометить определенный класс как Entity - сущность, необходимо над полем, являющимся у него первичным ключом, поставить аннотацию `@Id`. Javers будет сравнивать поля двух объектов между собой, только если у них совпадает первичный ключ.

Также над классом можно поставить аннотацию `@TypeName(String)`, с помощью которой можно задать человекочитаемое имя для сущности. Используется это в первую очередь для того, чтобы при сохранении различных версий сущности в БД, не менялось название таблицы, которое по умолчанию соответствует имени класса сущности.

Все классы, помеченные с помощью JPA аннотации `@Entity` будут считаться **Entity**.

### Определение Value Object

Javers по умолчанию воспринимает все объекты без поля, помеченного `@Id`, как **Value Object**.

Но если очень хочется, то можно повесить над классом аннотацию `@ValueObject`.

Все классы, помеченные с помощью JPA аннотации `@Embeddable` будут считаться **Value Object**.

### Определение Value

Для определения типа как Value, над ним нужно поставить аннотацию `@Value`. При этом нужно не забыть корректно переопределить в данном классе метод `equals()`, потому что сравнение Value-типов ведется именно с помощью этого метода.

### Способы настройки

- явно при создании объекта `Javers` с помощью методов `register...()`.
- явно с помощью аннотаций, освещенных выше.
- неявно с помощью механизмов наследования. Если у класса есть супертип, для которого определена модель, то Javers попытается применить эту модель к подтипу.
- воспользоваться настройками по умолчанию - все классы будут считаться **Value Object**.

## Создание собственного компаратора

Иногда необходимо сравнивать значения полей объектов по какому-то своему правилу. Возможно это правило будет индивидуальным для конкретно данного сравнения.

Кастомные компараторы бывают двух типов:

- для сравнения объектов **Value**-типа используются компараторы, унаследованные от `CustomValueComparator<T>`
- для каких-то сверхсложных сравнений, которые невозможно организовать никак иначе, используется `CustomPropertyComparator<T, C extends PropertyChange>`.

### Интерфейс `CustomValueComparator<T>`

В нем объявлены 2 метода:

- `boolean equals(T, T)` - сравнивает два объекта заданного типа и возвращает true, если они равны
- `String toString(T)` - используется для двух целей: вместо хэшкода и для создания идентификаторов объектов Value типов (но это не точно).

Реализовав интерфейс, и зарегистрировав его в Javers можно добиться того, что Value-объекты будут автоматически сравниваться не с помощью стандартного `Object.equals()`, а с помощью метода `equals(T, T)`.

Также данный интерфейс можно реализовать анонимно с помощью лямбда-выражений при создании объекта `Javers`:
```java
JaversBuilder.javers()
    .registerValue(MyClass.class, (a, b) -> a.compareTo(b) == 0, a -> a.toString())
    .build()
```

### Интерфейс `CustomPropertyComparator<T, C extends PropertyChange>`

В нем объявлен один метод:

- `Optional<C> compare(T, T, PropertyChangeMetadata, Property)` -

Используется редко, изучить по мере необходимости

Для использования кастомных компараторов при сравнении объектов необходимо зарегистрировать их в Javers при его создании:
```java
Javers javers = JaversBuilder.javers()
    .registerValue(MyClass.class, new MyCustomValueComparator())
    .registerCustomType(Custom.class, new CustomPropertyComparator())
    .build();
```

## Исключение из рассмотрения

Если требуется не рассматривать какие-либо поля при поиске различий, над ними необходимо повесить аннотацию `@DiffIgnore`.

Также аннотацию `@DiffIgnore` можно повесить на класс, однако при этом javers все равно будет отслеживать изменения в коллекциях параметризованных таким классом.

```java
@Data
public class MyClass {
    private int id;

    @DiffIgnore
    private String ignored;

    private List<Inner> notIgnored; //не игнорируется, хотя класс Inner помечен аннотацией @DiffIgnore

    private Inner ignoredInner; //игнорируется

    @DiffIgnore
    private List<String> ignoredList;

    @Data
    @DiffIgnore
    public class Inner {
        private String name;
    }
}
```

Аннотация JPA `@Transient` воспринимается Javers точно также, как `@DiffIgnore`.

Для сравнения объектов типа Entity только по идентификатору, над классом можно поставить аннотацию `@ShallowReference`. Такую аннотацию логично проставлять над Immutable объектами, первичный ключ которых полностью определяет внутреннее содержание.

Также эту аннотацию можно ставить над полями и методами.

Если необходимо игнорировать только поля, объявленные в дочернем классе, но принимать в расчет поля родительского класса, то можно пометить дочерний класс аннотацией `@IgnoreDeclaredProperties`.

Если из всего класса нужно оставить для рассмотрения только пару полей и лениво писать над остальными `@DiffIgnore`, то можно поставить над необходимыми полями аннотацию `@DiffInclude` - остальные поля не будут рассматриваться.

---
## Обработка найденных различий

В результате определения различия между версиями объектов Javers создает объект класса `Diff`, в котором хранятся все различия. Достать их оттуда можно с помощью метода `getChanges()`.

Каждое различие представляет собой объект класса `Change`. Этот класс абстрактный и у него есть следующие реализации (**типы различий**):

- `NewObject` - добавился новый объект.
- `ObjectRemoved` - удалился объект.
- `PropertyChange` - поле изменило свое значение. Подтипы:
    - `ReferenceChange` - изменилась ссылка на объект (наверное актуально для Value Object'ов).
    - `ValueChange` - изменение значение Value-значения, вроде строки или int.
    - `ListChange` - изменения в списке, например добавление или удаление объектов из списка.
    - `SetChange` - изменения в множестве, например добавление или удаление объектов из множества.
    - `MapChange` - изменилось отображение.
    - `ArrayChange` - изменился массив.

Из объекта `Diff` можно вытащить различия определенного типа с помощью метода `getChangesByType()`:
```java
ValueChange change = diff.getChangesByType(ValueChange.class).get(0);
```

---
# Хранение различий в БД

<mark>заполнить по мере необходимости</mark>

---
# Прочее

## Подключение зависимости

Для использования библиотеки в своем проекте необходимо в Maven подключить зависимость
```xml
<dependency>
    <groupId>org.javers</groupId>
    <artifactId>javers-core</artifactId>
    <version>${javers.version}</version>
</dependency>
```

---
## Идеи по улучшению библиотеки

Иногда необходимо кастомизировать сравнение версий объекта в части правил сравнения.

Для таких случаев было бы удобно определить в аннотации `@DiffIgnore` параметр группы сравнения с неким дефолтным значением. Если у аннотации значение равно дефолтному, значит ее необходимо учитывать при всех сравнениях версий объектов. Также с помощью значения можно задать группу, для которой правило сравнения будет отличаться от стандартного.

При создании объекта `Javers` можно передавать ему название группы, чтобы при сравнении он отфильтровывал аннотации, относящиеся к другим группам.

```java
Javers customJavers = JaversBuilder.javers("customGroup").build();
```

---
## К изучению

- Официальный сайт библиотеки: https://javers.org/
- github библиотеки: https://github.com/javers/javers