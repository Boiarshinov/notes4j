---
title: "Обработка исключений в Spring Web"
tags:
  - spring
  - web
draft: false
---

Каждый запрос к приложению потенциально может закончиться ошибкой. В таких случаях выбрасывается исключение, которое летит до тех пор, пока не будет перехвачено, иначе приложение падает с ошибкой. Поэтому критически важно, чтобы приложение перехватывало все исключения.

В веб-окружении обработкой исключений занимается контейнер сервлетов, убивая треды, выбросившие исключения, и возвращая пользователю сообщение об ошибке. Проблема заключается в том, что ошибки могут быть различными и могут содержать в себе полезную информацию для пользователя. Эта информация может быть представлена в виде HTTP-кодов ошибок и в виде тела респонса.

Но для того чтобы выдать пользователю нужную информацию об ошибке необходимо перехватить исключение самостоятельно и описать вид ответа.

Так как точками входа в веб-приложение являются контроллеры, то обработка исключений обычно прописывается в них.

---
## Обработка исключений в контроллере

Одним из вариантов обработки исключений: обернуть каждый метод в блок try-catch, последовательно обрабатывая каждый вид исключения. Но Spring предоставляет более удобный способ.

В Spring приложениях в контроллере могут быть представлены специальные методы, помечаемые аннотацией `@ExceptionHandler`, которые принимают определенные виды исключений и подготавливают ответ для пользователя.

В параметрах аннотации можно указать какие типы исключений она будет перехватывать. Если их не указывать, то она будет перехватывать все подтипы исключения, указанного в аргументах метода.
```java
@ExceptionHandler({
    MissingServletRequestParameterException.class,
    ConstraintViolationException.class,
    HttpMessageNotReadableException.class
})
public String badRequestExceptionHandler(final Exception exception) {
    return "У вас обшибочка";
}
```

В REST-контроллерах ответ пользователю чаще всего оборачивается в объект класса `ResponseEntity`, который помимо сообщения об ошибке (может быть представлено не только строкой, но и объектом)  инкапсулирует в себе HTTP-код ошибки.

Для создания объекта `ResponseEntity` предусмотрен удобный DSL:
```java
@ExceptionHandler(NoSuchElementException.class)

public ResponseEntity<ErrorInfo> elementNotFoundExceptionHandler(final NoSuchElementException exception) {

    final ErrorInfo errorInfo = new ErrorInfo("Object not found", exception.getMessage());

    return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorInfo);
}
```

---
## Глобальный обработчик исключений

Когда в приложении становится много контроллеров, в них начинает дублироваться код обработки исключений. В таком случае хочется вынести их в отдельное место. Для этого в Spring  необходимо создать отдельный класс, помеченный аннотацией `@ControllerAdvice`. Внутри этого класса объявляются методы, обрабатывающие различные виды исключений.

Это делается точно так же, как в контроллерах с помощью аннотации `@ExceptionHandler` (см. выше).
```java
@ControllerAdvice
public class ControllerExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)

    public ResponseEntity<List<ConstraintViolationInfo>> handleMethodArgumentNotValidException(

            final MethodArgumentNotValidException exception
    ) {
        /* */
    }
}
```

Подобных классов может быть несколько для различных групп API. Разделить область применения конкретного `@ControllerAdvice` можно с помощью указания пакета с контроллерами, для которого этот обработчик будет применим. Делается это с помощью специального параметра аннотации `basePackages`:
```java
@ControllerAdvice(basePackages = {"dev.boiarshinov.demo.legacycontrollers"})
```
Для REST-контроллеров существует специальный `@RestControllerAdvice`, который позволяет не писать над каждым методом `@ResponseBody`.

---
## Рекомендации по обработке исключений

### Обработка неожидаемых исключений

Если исключение не обработано в `ControllerAdvice`, то за него берется контейнер сервлетов. Формат вывода контейнера сервлетов может очень сильно отличаться от формата, принятого в системе. Что может стать очень неприятным для клиентов приложения.

Поэтому в глобальном обработчике исключений желательно иметь один самый обобщенный перехватчик исключений, который работает с `Exception.class` или даже с `Throwable.class`.  В веб-приложениях такой обработчик должен возвращать HTTP-код 500.

### Оповещение об ошибках сервера

В идеале приложение никогда не должно отдавать HTTP-код 500. Потому что это явно свидетельствует о баге. Но когда такие ошибки происходят - хотелось бы пофиксить их как можно скорее.

Именно поэтому мне кажется хорошей идеей встроить в самый обобщенный перехватчик исключений оповещение об ошибке, которое будет падать на почту / в телеграм разработчика.

Здесь возникает проблема с тем, что при определенных обстоятельствах (например, потеряно соединение с базой данных) ошибки могут генерироваться со скоростью мира. В этом случае будет слишком много оповещений об ошибках и разработчик перестанет обращать на них внимание.

Стоит заняться поиском решения этой проблемы

### Когда кидать 404

Рассмотрим точку входа в приложение, в которой нужно извлечь из БД данные и что-то с ними сделать. Что если сущности с указанным идентификатором в БД нет? Какой HTTP-код нужно возвращать?

HTTP-код 404 предназначен для того, чтобы сигнализировать о том, что запрошенный ресурс не существует. HTTP-код 400 для того, чтобы уведомить пользователя об ошибке в его запросе.

На мой взгляд необходимо возвращать 404, если идентификатор запрашиваемой сущности был указан в пути URL, например так:
```
<host>/entity/{id}/info
```
Если же идентификатор был передан в виде параметра URL или в теле POST запроса, то необходимо возвращать 400.

Для этого можно создать два собственных класса исключений, унаследованных к примеру от `EntityNotFoundException`. Один из них будет предназначен для возвращения 400 ошибки, а второй для 404.

Но что же делать, если исключение выбрасывается в компоненте, который может использоваться как ресурсом, в котором идентификатор приходит в пути URL, так и ресурсом, где идентификатор приходит в виде параметра URL или внутри тела POST-запроса?

Получается придется обрабатывать такие исключения не в `ControllerAdvice`, а напрямую в контроллере.

---
## К изучению
- [X] Курс Spring & Hibernate for Beginners на Udemy в части касающейся
- [ ] Javadoc на упомянутые классы / аннотации