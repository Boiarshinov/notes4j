---
title: "Spring Транзакции"
tags:
  - java_and_db
  - spring
draft: false
---

О том что такое транзакции можно почитать тут: [Транзакции](evernote:///view/170585988/s440/abe775e9-de81-4b56-b51c-f342b261aa3d/326914af-80f0-4f87-a7f5-03a088fd06d8/), а о требованиях к ним предъявляемых тут: [ACID](evernote:///view/170585988/s440/4ed0e8a7-b041-4ec5-6d44-3b890a50c6d6/326914af-80f0-4f87-a7f5-03a088fd06d8/).

Spring транзакции могут использоваться вместо `EntityTransaction` из [JPA](../jpa/jpa.md).

Spring Транзакции входят в Spring Framework, а все классы, относящиеся к ним, находятся в пакете `org.springframework.transaction`.

Обычно работа с транзакциями описывается на сервисном уровне, так как бизнес-логика приложения может существенно зависеть от состояния данных в БД.

Spring поддерживает два вида управления транзакциями:

- Программный способ. Очень гибкий и нелаконичный. Почти не используется
- Декларативный способ. Реализуется путем навешивания аннотаций `@Transactional`.

---
## Декларативный способ

Для включения транзакционности необходимо над одним из конфигурационных классов повесить аннотацию
```java
@Configuration
@EnableTransactionManagement
public class TransactionConfig {
}
```

Для того чтобы объявить транзакционность какого-либо метода, над ним вешается аннотация `@Transactional`.

Под капотом Spring создает для метода, помеченного аннотацией, динамическое прокси, которое следит за отсутствием исключений.

Аннотация может вешаться и на класс, тогда она будет распространяться на все его методы.

Транзакции откатываются, если во время выполнения метода (пока он лежит на стеке), выбрасывается непроверяемое исключение или ошибка.

Транзакции, использующиеся только для чтения помечаются с помощью параметра `readOnly`.

### Управление транзакциями

Вся работа с транзакциями разруливается с помощью различных реализаций `TransactionManager`. Задать определенную реализацию менеджера транзакций можно с помощью параметра аннотации `transactionManager`.

### Распространение транзакции

Вид распространения транзакции задается с помощью параметра `propagation`, которому может быть передано одно из следующих значений:

- `REQUIRED` - Данный метод не может работать без активной транзакции. Если поток управления зашел в этот метод с уже существующей транзакцией, то он продолжает выполняться в рамках этой транзакции. Если до этого транзакции не существовало, то она будет создана. Является значением по умолчанию.
- `SUPPORTS` - Метод может выполняться как при наличии транзакции, так и без. Если поток управления зашел в этот метод с уже существующей транзакцией, то он продолжает выполняться в рамках этой транзакции.
- `MANDATORY` - Данный метод не может работать без активной транзакции. Если транзакции не существует, то выбрасывается исключение.
- `REQURES_NEW` -
- `NOT_SUPPORTED` - Метод будет выполняться без учета транзакций. Если при заходе в метод существовала транзакция, то она продолжается. Используется, когда в методе не происходит никакой работы с БД.
- `NEVER` - Данный метод не может работать в транзакции. При ее наличии выбрасывается исключение.
- `NESTED` -  При входе в метод из транзакции создается транзакция внутри транзакции. Мы встроили тебе монитор в монитор ...

### Уровни изоляции

Одним из параметров аннотации `@Transactional` можно передать уровень изоляции транзакции.

Об аномалиях при чтении можно почитать в соответствующем разделе заметки [ACID](evernote:///view/170585988/s440/4ed0e8a7-b041-4ec5-6d44-3b890a50c6d6/326914af-80f0-4f87-a7f5-03a088fd06d8/).

Существует несколько уровней изоляции:

- `DEFAULT` - используется уровень изоляции, принятой в используемой БД
- `READ_UNCOMMITED` - самый слабый уровень изоляции. Не предотвращает ни одну из аномалий чтения.
- `READ_COMMITED` - запрещено чтение данных, незакоммиченных другими транзакциями. Предотвращает грязное чтение, но не спасает от неповторяющегося и фантомного чтения.
- `REPEATABLE_READ` - Предотвращает грязное и неповторяющееся чтение, но не спасает от фантомного чтения.
- `SERIALIZABLE` - Предотвращает все виды аномалий чтения: грязное, неповторяющееся и фантомное.

### Время жизни транзакции

Для того чтобы избежать мертвых транзакций, которые застряли посередине выполнения и не могут ни откатиться, ни закоммититься их принято убивать по достижению какого-то момента времени.

Максимальное время жизни транзакции можно задать с помощью параметра `timeout`. По умолчанию используется таймаут, заданный системой обработки транзакций, лежащей под капотом (//это еще что?).

### Обработка исключений

По умолчанию транзакции откатываются при возникновении непроверяемых исключений или ошибок. Но с помощью некоторых параметров можно гибко настроить список исключений:

- `rollbackFor` - явно указывается список исключений, при которых нужно откатить транзакцию. По умолчанию все непроверяемые исключения и ошибки. Используется чтобы указать проверяемые исключения, которые должны приводить к откату транзакции.
- `noRollbackFor` - явно указывается список исключений, при выбрасывании которых откатывать транзакцию не требуется. По умолчанию таких исключений нет.

---
## К изучению

- [X] Работа с транзакциями в Spring: https://habr.com/ru/company/otus/blog/431508/
- [ ] Транзакции в Spring Framework (как транзакции работают под капотом): https://medium.com/@kirill.sereda/%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B8-%D0%B2-spring-framework-a7ec509df6d2
- [ ] javadoc на `org.springframework.transaction`