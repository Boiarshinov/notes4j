---
title: "Log Structure Merge Tree"
tags:
  - data_structure
  - tree
draft: false
---

# Log Structure Merge Tree

LSM-дерево, это структура данных, объединяющая в себе хранение в памяти и на диске.
Благодаря чему эта структура данных является персистентной.

LSM-деревья используются в базах данных, оптимизированных на скорость вставки.
Например, в [Cassandra](../database/cassandra.md), Lucene (индексный движок для поисковых баз данных ElasticSearch и Apache Solr).


## Устройство

LSM-дерево состоит из нескольких частей:
- __memtable__ - сортированное дерево, хранящееся в памяти
- __SSTable__ - таблица отсортированных по ключу значений, хранящаяся на диске

Механизм работы LSM-деревьев следующий: при вставке данные записываются в __memtable__ (сокращение от in-memory table).
В memtable все записи сортируются по ключу.
При вставке новой версии записи с ключом, который уже был в memtable, значение перезатирается.
Когда количество записей в memtable превышает некоторое пороговое значение (например, несколько MB), то она сбрасывается на диск в SSTable.
__SSTable__ (сокращение от sorted string table) хранится на диске, значения в ней отсортированы по ключу.
SSTable является иммутабельной, т.е. работает только на чтение.
При каждом сбросе на диск создается новый файл SSTable.

Важно понимать, что memtable - всегда одна, а sstable может быть много.

При поиске по ключу, LSM-дерево в первую очередь смотрит в memtable, если ключ там не найден, то читает последний SSTable, если и в нем ключа нет, то в предыдущем и так далее.
Если ключ отсутствует в LSM-дереве, то чтобы понять это придется перечитать все SSTable. 
Для оптимизации определения отсутствующих ключей используется [фильтр Блума](./bloom_filter.md).

В LSM-деревьях для удаления записей по ключу используется костыль.
Ведь если мы просто удалим запись из memtable, то при поиске по ключу запись все равно будет найдена в одном из SSTable.
Поэтому вместо удаления происходит наоборот вставка специального значения, называемого __tombstone__ - надгробная плита.
Получается интересный парадокс, что удаление данных из LSM увеличивает объем хранимой информации, а не уменьшает его.


### Компакция

С течением времени в разных SSTable накапливается информация по дублирующимся ключам.
При этом актуальной является информация из последнего SSTable, в котором представлен ключ.
Получается, что на диске хранится устаревшая информацию, которую хорошо бы почистить.
Для этого применяется __компакция__ - процесс, при котором несколько SSTable объединяются в один.

Как правило компакция проводится отдельным процессом, работающим в параллель с основным процессом LSM-дерева.
Никаких гонок при этом не возникает благодаря тому, что SSTable являются иммутабельными.
Процесс вычитывает несколько SSTable, объединяет их в один, переопределяет путь до SSTable и только потом стирает устаревшие файлы.

Существуют различные стратегии определения условий начала проведения компакции:
- Size Tiered - основанные на размере
- Leveled - SSTable выстраиваются в дерево определенной высоты. Каждый уровень дерева и называется level


### Устойчивость к сбоям

Чтобы не потерять данные, хранящиеся в памяти в memtable, и еще не сброшенные на диск, в LSM-деревьях используется __WAL__ - __write ahead log__, он же __commit log__.
При вставке в LSM-дерево первым делом данные записываются в WAL и только потом в memtable. 
В WAL данные записываются в том порядке, в котором приходят запросы на вставку, ничего не сортируется.

Когда memtable скидывает данные на диск в SSTable, одновременно с этим процесс очищает WAL. 

В случае сбоя, когда процесс LSM-дерева запускается, то первым делом он вычитывает WAL и формирует на его основе memtable, и только потом начинает обрабатывать запросы на запись и чтение.



---
## К изучению

- [X] Книга. Martin Kleppmann. Designing data-intensive applications. Глава 3
- [ ] Книга Алекса Петрова "Распределенные данные", глава 7
