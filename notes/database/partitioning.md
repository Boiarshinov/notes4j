---
title: "Партиционирование"
tags:
  - database
draft: false
---

# Партиционирование

__Партиционирование__ - это разбиение хранимых данных на несколько единиц хранения (зачастую, файлов).
Партиционирование позволяет:
- проводить горизонтальное масштабирование базы данных;
- удалять старые партиции, если данные уже устарели и не нужны;
- хранить большие объемы данных, которые не поместились бы в файловую систему одним куском;
- ускорить запросы по ключам, на которых построено партиционирование, т.к. запрос будет выполняться только на части данных.

В реляционных БД стандарт SQL не устанавливает каким образом данные должны храниться на диске.
Поэтому различные СУБД вольны делать это по-своему.
Чаще всего информация по каждой таблице пишется в отдельный файл.
Если таблица получается очень большая, то файл вырастает до таких размеров, что с ним становится неудобно работать.
Поэтому многие СУБД предоставляют возможность партиционирования.

В NoSQL базах данных данных почти всегда партиционирование - это обязательная часть.
Например, в Kafka топики разделяются на партиции, где за каждую партицию отвечает свой брокер.
В Hazelcast, Cassandra и других key-value БД все ключи распределяются партициям.

Каждая партиция, как правило, [реплицируется](./replication.md) на другие ноды распределенной БД.
Делается это для отказоустойчивости - при выходе из строя одной ноды, принадлежащие ей партиции переезжают на другие ноды (реплики становятся ведущими).


### Распределение по партициям
При записи в БД можно выбирать партицию случайным образом, но тогда при чтении придется просканировать все партиции, чтобы найти искомую запись.
Поэтому чаще всего записи разделяются по партициям с помощью какого-либо признака.
Например, в реляционных БД очень часто проводят партиционирование по времени записи в таблицу, что позволяет отрезать старые данные.
Также часто данные распределяются по партициям на основе значений какого-либо ключа: географического региона, идентификатора клиента и пр.
И самый банальный метод - это по хэшу записи (или ее ключа). 
В этом случае каждая партиция принимает в себя диапазон значений хэша.

Недостаток партиционирования по времени записи - все новые записи проводятся в одну партицию, которая становится экстремально нагруженной на запись, пока остальные партиции отдыхают.
Для борьбы с этим иногда ключ партиционирования делают составным: первая часть - это какое-либо бизнес поле - например, идентификатор источника записи, а вторая часть - временная.

Отдельная проблема партиционирование - это изменение количества партиций.
При изменении количества партиций необходимо пересмотреть правила выбора партиций и провести миграцию данных между партициями.
Поэтому никогда не используется распределение по партициям на основе остатка от деления хэша на количество партиций. 
Так как при изменении количества партиций в таком случае приходится перемещать слишком большие объемы данных.

Одно из возможных решений - сделать количество партиций много больше количества нод БД. 
В этом случае при добавлении или выходе нод из кластера данные переезжают только целыми партициями.
Многие БД используют такой подход: Cassandra, Hazelcast, ElasticSearch.
Количество партиций нужно выбрать не слишком большим, чтобы снизить затраты на вспомогательные операции, но и не слишком маленьким, чтобы при масштабировании кластера БД распределение партиций по нодам было равномерным.

Некоторые БД умеют динамически разделять большие партиции на более мелкие, когда они выполняют какое-нибудь условие, например, занимают больше X ГБ на диске.
Так делает, например, HBase. оричные индексы
Отдельная проблема при партиционировании - это поиск по вторичным индексам.
Многие NoSQL базы даже не предоставляют возможности задавать вторичные индексы.

Существует два подхода к партиционированию вторичных индексов:
- __document based partitioning__ - партиционирование по документам
- __term based partitioning__ - партиционирование по термам (__терм__ - это термин из области полнотекстового поиска, означающий "слово")

При партиционировании по документам рядом с каждой партицией есть часть индекса, в котором индексированы только записи, принадлежащие этой партиции.
В этом варианте, чтобы извлечь нужные данные, придется сходить на все ноды БД и заглянуть в индекс каждой партиции.
Это может приводить к долгим чтениям, т.к. результат будет выдан не быстрее, чем ответ самой медленной ноды.
Тем не менее именно этот вариант используется в Cassandra, MongoDB, Elasticsearch и многих других БД.

При партиционировании по термам индекс I1 партиции P1 хранит в себе данные по всем партициям P1, P2, ..., Pn. 
Но при этом индекс I сам партиционирован по диапазону ключей.
Например, индекс I индексирует данные по геозоне, тогда в его партиции I1 будут храниться ссылки на записи с геозонами AM-BE, в партиции I2 - BU-DE и т.д.
Недостаток партиционирования по термам - это долгая запись, так как при записи данных в партицию P1 может потребоваться обновить различные вторичные индексы, нужные партиции которых могут лежать на других нодах БД.
Поэтому многие БД использующие партиционирование по термам делают обновление индексов асинхронным, что может приводить к их неактуальному состоянию.                    ииии 

---
## MySQL
В MySQL партиционирование всегда горизонтальное, то есть проводится по строкам, а не по колонкам.

При вставке новой записи нужно выбрать партицию, в которую будет произведена запись.
Выбор партиции делается с помощью __функции партиционирования__.
Эта функция принимает значения колонок вставляемой записи, на основе которых производится расчёт, и возвращает номер партиции.

В MySQL партиционирование бывает нескольких видов:
- Range - вхождение значения выбранной колонки в интервал значений. Хорошо подходит для партиционирования по времени
- List - вхождение значения выбранной колонки в список значений
- Hash - можно задать выражение, вычисляющее целочисленное значение из колонок вставляемой записи
- Key - то же, что и Hash, только еще используется встроенная в MySQL хэш-функция

При партиционировании важно помнить о следующем ограничении:
> Все колонки, использующиеся для партиционирования, должны быть частью всех уникальных ключей таблицы (в том числе первичного ключа).

```sql
CREATE TABLE my_table (
  id         bigint AUTOINCREMENT, 
  col        text                                not null, 
  created_at timestamp default CURRENT_TIMESTAMP not null,
  primary key(id, created_at)
)
PARTITION BY RANGE( UNIX_TIMESTAMP(created_at) ) (
  PARTITION p0 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
  PARTITION p1 VALUES LESS THAN ( UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
  PARTITION p2 VALUES LESS THAN (MAXVALUE)
);
```

---
## К изучению
- [X] [Документация MySQL. Партиционирование](https://dev.mysql.com/doc/refman/5.7/en/partitioning.html)
