---
title: "CQL"
tags:
  - database
  - nosql
draft: false
---

# CQL

**CQL** - [Cassandra](cassandra.md) Query Language.

Для взаимодействия с Кассандрой из терминала существует консольная утилита `cqlsh`. 
Она поставляется вместе с Кассандрой.
Утилита написана на питоне, поэтому для ее использования на сервере должен быть установлен Python.


## Типы данных
- `text` - строчка любой длины в UTF-8
- числовые типы:
  - `int` - 32-битное целое число
  - `bigint` - 64-битное целое число
  - `varint` - джавовый BigInteger
  - `float` - 32-битное число с плавающей точкой
  - `double` - 64-битное число с плавающей точкой
  - `decimal` - джавовый BigDecimal
- `timestamp` - 64-битное число, хранящее отступ в миллисекундах от Unix Time.
- `uuid` - UUID 1 или 4 версии. 128 бит
- `timeuuid` - UUID с `timestamp`'ом внутри, позволяющий сортировать записи во времени
- `boolean` - булевы значения
- `blob` - бинари
- коллекции:
  - `list` - значения в порядке вставки
  - `set` - уникальные значения
  - `map` - пары ключ-значения
- `counter` - счетчик
- `tuple` - структура
- `udt` - user define type - пользовательский тип


## DDL
### Создание keyspace
При создании keyspace (аналог схемы в РБД) обязательно указываются настройки репликации.
```cql
CREATE KEYSPACE my_business
WITH REPLICATION = {
  'class': 'SimpleStrategy',
  'replication_factor': 1
}
```

### Создание таблицы
Создание таблицы начинается с ключевых слов `CREATE TABLE`:
```cql
CREATE TABLE my_table
( id int PRIMARY KEY, value text );
```

Если первичным ключом является одна колонка, то можно написать `PRIMARY KEY` сразу после ее объявления.
Но так бывает редко.
Чаще всего первичный ключ составной и тогда он объявляется после всех столбцов отдельным выражением:
```cql
CREATE TABLE t1
( gauge_id int, measured_at timestamp, value decimal, 
    PRIMARY KEY(gauge_id, measured_at)
);
```

При этом первый столбец, указанный в `PRIMARY KEY` будет считаться ключом партиционирования (**partition key**), а совокупность остальных столбцов - кластерным ключом (**clustering key**).
Все записи с одинаковым ключом партиционирования всегда попадают в одну ноду.
Ключ партиционирования может быть составным, в этом случае его колонки заключаются в скобки:
```cql
CREATE TABLE t1
( gauge_id int, date timestamp, measured_at timestamp, value decimal, 
    PRIMARY KEY((gauge_id, date), measured_at)
);
```

#### Предсортировка
При создании таблицы можно задать сортировку по одному или нескольким кластерным ключам.
Делается это при помощи ключевых слов `WITH CLUSTERING ORDER BY`:
```cql
CREATE TABLE t1
( gauge_id int, date timestamp, measured_at timestamp, value decimal, 
    PRIMARY KEY((gauge_id, date), measured_at)
) WITH CLUSTERING ORDER BY (measured_at DESC);
```

Чаще всего это делается для данных, которые должны быть отсортированы по времени так, чтобы в начале лежали самые свежие данные.


### Создание индекса
```cql
CREATE INDEX ON my_table(index_column);
```
Индекс на самом деле представляет собой отдельную таблицу, в которой ключами являются значения `index_column`, а значениями - список идентификаторов записей из основной таблицы.

Составных индексов не бывает.

В индекс записываются только те записи, которые принадлежат данной ноде.
Селект по индексу в любом случае будет работать медленнее, чем селект по первичному ключу, т.к. необходимо будет заглянуть в индекс на каждой ноде.


### Метаданные
CQL позволяет извлечь метаданные о таблицах и кейспейсах.
Метаданные о таблице можно получить с помощью команды `DESCRIBE TABLE`:
```cql
DESCRIBE TABLE t1;
```


---
## DML
### Выборка данных
Выборка данных очень похожа на SQL, но обладает урезанными возможностями.
```cql
SELECT * FROM table;
SELECT first_column, second_column FROM table;
SELECT * FROM table WHERE id = 1;
```

В `WHERE` обязательно должен быть указан partition key.
Также в `WHERE` дополнительно могут быть указаны колонки из primary key.
Любые другие колонки можно указывать только, если до этого были перечислены все колонки из primary key.
Отдельно обычные колонки указывать нельзя, т.к. поиск по ним будет приводить к чтению из всех нод.

Если чтение из всех нод нас не пугает, то к запросу нужно добавить в конце `allow filtering`.


### Вставка
Стандартный синтаксис - `INSERT INTO`
```cql
INSERT INTO users (user_id, first_name, second_name)
VALUES (uuid(), 'John', 'Doe');
```

Есть специальный синтаксис для импорта данных из CSV-файлов:
```cql
COPY table (column1, column2, column3) FROM 'data.csv';
```

Инсерт вставляет данные, если их не было, и обновляет их, если они были.
То есть по сути работает как Апсерт.


### Обновление
```cql
UPDATE table
SET column=value
WHERE predicate = true;
```
`WHERE` - должен быть обязательно

Апдейт обновляет данные, а если их не было, то вставляет их.
То есть по сути работает как Апсерт.
Иными словами нет никакой разницы между `INSERT INTO` и `UPDATE`.

`UPDATE` позволяет сделать compare-and-set с помощью оператора `IF`
```cql
UPDATE table
SET column=value, version = NOW()
WHERE predicate=true
IF version = 'uuid'
```
Если version не изменилось, то произойдет перезапись.
Если version поменялось, то Кассандра не будет обновлять запись и вернет клиенту текущее значение.

При обновлении можно задать TTL:
```cql
UPDATE table
USING TTL 3600 
# ...
```

### Удаление

- `DELETE` - устанавливает томбстоун
- `TRUNCATE` - чистит таблицу, удаляя файлики sstable (переносит в специальную директорию `truncated`)
- `DROP` - удаляет всю таблицу с концами


---
## Встроенные функции
- `token(<partition_key>)` - выводит токен для конкретного значения ключа партиционирования


---
## Батчи
Батч - это пачка из нескольких записей `INSERT`, `UPDATE`, `DELETE`.
Батч выполняется атомарно (но не изолировано).
С помощью батча можно имитировать транзакцию.
```cql
BEGIN [UNLOGGED] BATCH
INSERT
APPLY BATCH;
```

`UNLOGGED` - 


---
## Источники

- [X] Курс по Cassandra от Luxoft