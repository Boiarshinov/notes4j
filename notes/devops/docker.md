---
title: "Docker"
tags:
  - devops
draft: false
---

**Docker** - это приложение, позволяющее упаковывать приложения в контейнеры для их запуска в изолированной среде.

Docker является дальнейшим развитием виртуальных машин (VM-Ware, Hyper V).
![docker logo](../../images/docker_logo.png)

Контейнеры предназначены для упрощения процесса разворачивания приложения в различных средах. Приложение можно поместить в контейнер и быть уверенным, что оно будет работать одинаково на разных операционных системах.

Контейнеры бывают двух видов:

- Linux-контейнеры. Первоначально единственный вид контейнеров
- Windows-контейнеры. Появились в 2018 году.

**Image** - образ приложения, который используется, для того чтобы создать контейнер.
Image содержит в себе бинарный код приложения и его зависимостей.
Помимо этого в Image содержатся метаданные и подсказки о том, как запускать этот образ.
Image не включает в себя полноценную операционную систему, т.к. основные части ядра предоставляются самим докером.

**Container** - это инстанс приложения, полученного из образа, запущенный в изолированном окружении

**Registry** - реестр докер-образов. Дефолтный реестр для докера - это Docker Hub

### Отличие докера от виртуальных машин

Запущенный контейнер докера в отличие от виртуальной машины является обычным процессом


## Образы
Докер образ

Официальный реестр докер-образов - это [Docker Hub](https://hub.docker.com/)

Названия образов записываются по следующему правилу:
```
<user>/<repo>:<tag>
```
, где 
- `user` - имя разработчика или наименование организации, собравшей образ. Например, `boiarshinov` или `pivotal`.
- `repo` - название проекта. Например, `openapi-cli` или `nginx`
- `tag` - версия образа. Например, `3.8.4` или `latest`.


Часто можно встретить образы каких-либо приложений с постфиксом `alpine`. 
Это означает, что приложение запаковано в сборку linux, в которой нет ничего лишнего, и потому она имеет минимальный размер.

Образы собираются по инструкциям, которые перечисляются в специальном файле - [Dockerfile](dockerfiles.md).

### Слои
Каждый докер-образ разбивается на слои.
Слои нужны для того, чтобы уменьшить объем, занимаемый слоями в реестре.
Также слои уменьшают сетевые издержки, т.к. нет необходимости выкачивать слой, который уже есть в локальном реестре.

Например, образ mysql может состоять из ОС Ubuntu, на которую установлен apt, с помощью которого уже установлена mysql.
Т.е. образ будет состоять из слоев:
```
^ mysql
| apt
| ubuntu
```

Если какой-нибудь другой образ тоже имеет слой с ubuntu той же версии, то реестру достаточно будет хранить этот слой только один раз.
Благодаря этому в совокупности докер-образы занимают меньше места, чем сумма объемов каждого по отдельности.

По сути контейнер - это еще один слой над образом, который разрешает IO операции над тем, что внутри образа.

### Тэги
Продукты, которые запаковываются в докер-образы, развиваются, а значит нужно как-то различать между собой их различные версии.
Для этого служат тэги.
Тэг - это указатель на конкретное состояние (коммит) образа.
Это не совсем версия, потому что в различных случаях один и тот же тэг может указывать на разные версии образа.
К тому же несколько разных тэгов могут указывать на одну версию образа.

Существует специальный тэг `latest`, который должен всегда ссылаться на последнее состояние образа.
Если при работе с образом тэг не указан, то по умолчанию используется `latest`.

`latest` не всегда указывает на последнюю версию, это лишь рекомендации от разработчиков докера о том, как нужно использовать этот тег.
Зачастую он ссылается на последнюю стабильную версию образа.
В `mysql` долгое время `latest` ссылался на версию 5.7, хотя уже была доступна версия 8.0.


---
## Персистентные данные

По своей задумке контейнеры должны быть иммутабельными.
Т.е. при перезапуске контейнера не должны теряться какие-либо данные.
Но многим приложениям необходимо иметь состояние, например базам данных.
Для этого в Docker используются две вещи
- **volume** - директория в файловой системе, к которой предоставляется доступ контейнеру
- **bind mount** - связка между директорией в файловой системе и директорией внутри контейнера

### Volume
**Volume** - директория в файловой системе, к которой предоставляется доступ контейнеру. 
По умолчанию при создании Volume данные контейнеров будут храниться в директории `<path>/docker/volumes/<volume_id>/`, где `path` - путь до директории докера, а `volume_id` - идентификатор конкретного volume, привязанного к какому-либо контейнеру.

Из-за просчетов в проектировании докера, очень тяжело разобраться какой Volume какому контейнеру принадлежит.
Поэтому были добавлены именованные Volume.
```sh
docker volume create <volume_name>:<container_path>
```
, где
- `volume_name` - наименование Volume. Можно написать что угодно, лишь бы потом самому разобраться какому контейнеру это принадлежит
- `container_path` - путь внутри контейнера, куда будет подключена директория из внешней файловой системы


### Bind Mount
**Bind mount** - связка между директорией в файловой системе и директорией внутри контейнера.
Bind mount можно подключить только при старте контейнера:
```sh
docker run -v <outside_path>:<container_path>
```
При этом зачастую используется shell-команда `$(pwd)` для указания на текущую директорию.

Основная область применения Bind Mount - локальная разработка с использованием инструментов, которые легче запустить в docker контейнере, чем устанавливать.
Чаще всего это какие-либо консольные утилиты, которые должны каким-либо образом работать с файлами в нашей среде разработки.
Для того чтобы дать доступ этим инструментам к нашим файлам, приходится использовать bind mounts.


---
## Неперсистентные данные
Также к контейнеру можно подключить `tmpfs`.
`tmpfs` - это область памяти на хосте, которая выделяется для контейнера.
После остановки контейнера память очищается, все данные пропадают.
При создании `tmpfs` указывается директория внутри контейнера, данные в которой будут храниться в памяти хоста.
```sh
docker run --tmpfs /dir_in_container 
```

`tmpfs` очень полезны при создании readonly контейнеров, которым нужно создавать временные файлы.
Например Spring Boot приложения с Tomcat создают несколько временных файлов в директории `/tmp` на старте приложения.


---
## Docker CLI

Докер имеет командный интерфейс под все популярные терминалы: bash, zsh, powershell

Командный интерфейс докера весьма прост:
```sh
$ docker <command> <options>
```

С развитием докера команд стало так много, что их решили разбить на группы и вызывать их теперь можно по шаблону
```sh
$ docker <command> <sub-command> <options>
```

Но предыдущий способ все еще работает.

Полный список команд можно посмотреть, выполнив `$ docker`

Команды для работы верхнеуровневой работы с контейнерами:

- `docker container ls` или `docker ps` - выводит список всех запущенных контейнеров
- `docker container ls -a` - выводит список всех существующих контейнеров
- `docker container run --publish <host_port>:<container_port> <app>` - запускает новый контейнер
- `docker container start <container_name>` - запускает существующий контейнер
- `docker container stop <container_name>` - останавливает работающий контейнер
- `docker container rm <container_name/id>` - удаляет контейнер
- `docker image ls` - выводит локальный реестр образов

Заглянуть внутрь контейнера можно с помощью команд:

- `docker container log <container_name>` - выводит логи приложения, запущенного в контейнере с указанным именем
- `docker container top <container_name>` - выводит список процессов, запущенных внутри контейнера
- `docker container inspect <container_name>` - детали конфигурации контейнера в формате JSON
- `docker container stats <container_id>` - рантайм параметры контейнера
- `docker container exec -it <container_name> bash` - заходит в терминал самого контейнера, подобно тому, как это делается через SSH

### Имена контейнеров

При создании нового контейнера ему можно указать имя, которое затем будет отображаться при работе с данным контейнером и будет использоваться для обращения к нему. Если этого не сделать, то докер сам сгенерирует ему имя по шаблону <эпитет> <имя хакера/ученого>.

Задать имя контейнеру можно при его создании с помощью опции `--name <container_name>`.

### Запуск контейнера

При запуске контейнера происходит следующее:

- Докер ищет нужный образ в своем кэше.
- Если в кэше нет нужного образа, то он обращается к реестру образов (по умолчанию это Docker Hub)
- Образ скачивается с удаленного репозитория и сохраняется в кэш
- Докер создает новый контейнер на основе образа
- Докер присваивает контейнеру виртуальный IP во внутренней сети докера
- Докер устанавливает взаимосвязь между портом системы и портом в контейнере, если это было задано с помощью опции `--publish <host_port>:<container_port>`
- Докер запускает приложение внутри контейнера с параметрами, которые были указаны в докерфайле


### Образ
- `docker pull <image_name>` - выкачивает в локальный кэш образ из глобального реестра
- `docker image history <image_name>` - показывает слои образа
- `docker image inspect <image_name>` - показывает метаданные образа
- `docker build -t <image_name> <dir>` - собирает образ с указанным названием из указанной директории. В этой директории должен находиться Dockerfile
- `docker push <image_name>` - выкладывает образ в реестр
- `docker image prune` - чистит лишние образы


---
## К изучению

- [X] [Курс Docker Mastery](https://www.udemy.com/course/docker-mastery/) на Udemy в части касающейся
- [ ] [Официальная документация](https://docs.docker.com/)
- [ ] Видеокурс [Docker от А до Я](https://www.youtube.com/playlist?list=PLD5U-C5KK50XMCBkY0U-NLzglcRHzOwAg)
- [X] [Docker Hub](https://hub.docker.com/)
