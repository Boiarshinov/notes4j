---
title: "Bean Validation"
tags:
  - java_ee
draft: false
---

# Bean Validation

Bean Validation - это стандарт, входящий в состав [Java EE](../java_ee/java_ee.md) (начиная с версии 6.0)и позволяющий валидировать приходящие значения на удовлетворение каким-либо условиям.

Начиная с версии 2.0 для использования библиотеки в своем проекте необязательно подтягивать зависимость всей Java EE.

Bean Validation представляет собой спецификацию, реализовывать которую могут различные вендоры.

Реализации:
- Hibernate Validator - единственная успешная реализация.
- [Apache BVal](http://bval.apache.org/index.html) - еще одна реализация, которая почему-то не признана Bean Validation 

С помощью Bean Validation можно валидировать следующее:
- обязательность поля
- валидация значений чисел
- валидация длины строки / числа
- валидация по регулярному выражению
- кастомная валидация

Весь код Bean Validation находится в пакете `javax.validation`, который необходимо подключать к проекту отдельно.

---
## Использование

Bean Validation позволяет устанавливать ограничения на значения полей (а еще аргументов методов) объектов с помощью установки аннотаций, несущих в себе метаданные об ограничениях.
Аннотации могут ставиться на поля, на аргументы метода, на целый класс и даже на обобщенные типы в классах-контейнерах.
Вот к примеру обычный модельный класс, в котором с помощью аннотаций Bean Validation установлены ограничения на значения ряда полей:

```java
@ValidUser
public class User {
    @NotNull private String name;
    @Email private String email;
    @Min(18) private int age;
    @NotEmpty private List<@Skill Skill> skills;
    
    /* ... getters, setters, etc. */
}
```

Проверка соответствия объекта заданным ограничениям выполняется с помощью специального валидатора:
```java
ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();
Set<ConstraintViolation<User>> violations = validator.validate(user);
```

Класс `Validation` - это входная точка в библиотеку Bean Validation.
С его помощью можно выбрать конкретную реализацию стандарта Bean Validation и настроить фабрику валидаторов.
В простейшем случае можно использовать метод `buildDefaultValidatorFactory()`.

После создания валидатора <mark>А зачем их может быть много?</mark> можно проверить соответствие ограничениям какого-либо объекта.
В результате будет возвращено множество нарушений ограничений. 
Если нарушений нет, то множество будет пустым.

<mark>Как происходит сканирование аннотаций и вытаскивание значений?</mark>

---
## Валидирующие аннотации

### Общего назначения

- `@NotNull` - проверяет, что поле имеет значение, отличное от *null*. *Важно*: не работает для примитивных типов - необходимо использовать классы-обертки.
- `@Null` - проверяет, что поле имеет значение *null*.

### Числа

- `@Min` - проверяет, что число больше указанного минимального значения.
- `@Max` - проверяет, что число меньше указанного максимального значения.
- `@Negative` - число должно быть отрицательным.
- `@Positive` - число должно быть положительным.
- много других

```java
@Positive
@Max(100500)
private final Integer salary;
```

### Строки

- `@NotBlank` - строка не должна быть пустой.
- `@Size` - длина строки должна быть в указанных пределах
- `@Pattern` - проверяет, что строка удовлетворяет регулярному выражению.
- `@Email` - валидирует, что строка представляет собой валидный e-mail адрес.

### Логические переменные

- `@AssertTrue` - проверяет, что логическая переменная имеет значение true
- `@AssertFalse` - проверяет, что логическая переменная имеет значение false

### Даты / Время

- `@Future` - проверяет, что значение даты находится в будущем относительно текущего времени
- `@Past` - проверяет, что значение даты находится в прошлом относительно текущего времени

### Коллекции

- `@Size` - задает ограничение по количеству элементов в коллекции минимальным и максимальным значением.
- `@NotEmpty` - проверяет, что в коллекции не пустая

---
## Создание собственных правил валидации

Для создания собственных правил валидации необходимо сделать две вещи:
1. Создать аннотацию, которая будет проставляться над полями, требующими нестандартной валидации
2. Создать класс-валидатор, который будет производить необходимые проверки.

### Создание аннотации

Создание пользовательской валидирующей аннотации почти ничем не отличается от создания обычной [аннотации](annotations.md).

`@Retention` должно быть задано значением `RetentionPolicy.RUNTIME`, так как аннотация будет работать во время выполнения.

`@Target` должно быть задано значением `ElementType.FIELD`, если планируется ставить аннотацию над полями класса, или `ElementType.METHOD`, если аннотацию планируется ставить над сеттерами. Можно задать оба этих значения (и даже больше).

Нетипичным шагом является навешивание аннотации `@Constraint`, в которой необходимо указать класс-валидатор, который будет производить проверки.

Для этого в аннотации нужно присвоить значение атрибуту `validatedBy` значение типа `Class`.

Также в аннотации обязательно должны быть определены следующие параметры:

- `String message()` - сообщение об ошибке. Обычно в целях интернализации в дефолтное значение вписывают название ключа, по которому можно найти текст сообщения в properties-файлике нужной локали. По соглашению значение ключа должно соответствовать полному пути до класс-файла аннотации `dev.boiarshinov.project.validation.MyConstraint.message`.
- `Class<?>[] groups()` - для кастомизации групп. Каждая валидация может проходить в рамках какой-либо группы валидации. Если ни одной группы не передано, то используется группа `Default`.
- `Class<? extends Payload>[] payload()` - метаданные о конкретном использовании ограничения. `Payload` - это маркировочный интерфейс, нужный для обеспечения типобезопасности. Авторы библиотеки подразумевали, что `Payload` можно будет достать из `ConstraintViolation` и на основе его значения выстроить последующую бизнес-логику.

Полный пример создания пользовательской аннотации приведен ниже:
```java
@Constraint(validatedBy = MyConstraintValidator.class)
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface MyConstraint {
    public String value();

    public String message() default "{dev.boiarshinov.project.validation.MyConstraint.message}";
    public Class<?>[] groups() default {};
    public Class<? extends Payload>[] payload() default {};
}
```

#### Объединение ограничений

Иногда требуемое ограничение может быть композицией нескольких существующих ограничений. 
Например, телефонный номер можно описать двумя ограничениями: размер строки и регулярка на цифры.
Тогда удобно создать одну композитную аннотацию
```java
@Pattern("\\d*")
@Size(min = 10, max = 10)
@ReportAsSingleViolation
@@Constraint(validatedBy = PhoneValidator.class)
@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Phone {

    public String message() default "{dev.boiarshinov.project.validation.Phone.message}";
    public Class<?>[] groups() default {};
    public Class<? extends Payload>[] payload() default {};
}
```
При нарушении значением сразу нескольких ограничений будет получено сообщение по каждому из них.
Если хочется, чтобы сообщение было только одно, то нужно повесить аннотацию `@ReportAsSingleViolation`.
В этом случае при нарушении любого из ограничений в отчет попадет сообщение только композитной аннотации.


### Создание класса-валидатора

Кастомный валидатор должен реализовывать интерфейс `ConstraintValidator`. Этот интерфейс является обобщенным и для него необходимо указать два класса: аннотацию, которая ставится над валидируемым полем, и класс валидируемого поля.

```java
public class MyConstraintValidator implements ConstraintValidator<MyConstraint, String> { /* ... */ }
```

Также необходимо реализовать два метода:

- `void initialize(A annotation)` - инициализирует валидатор в соответствии со значениями параметров, определенных в аннотации. (Метод дефолтный, его можно не переопределять, если у аннотации нет аргументов). Пример использования можно посмотреть в валидаторе аннотации `@INN` hibernate-validator.
- `boolean isValid(T value, ConstraintValidatorContext)` - true, если пришедшее значение удовлетворяет ограничению.

Считается хорошим тоном возвращать true, если в метод `isValid()` приходит null. 
Для того чтобы запретить аннотированному параметру принимать значение null, разработчик должен дополнительно навесить на него ограничение `@NotNull`.

```java
public class MyConstraintValidator implements ConstraintValidator<MyConstraint, String> {

    private String valueFromAnnotation;

    @Override
    public void initialize(final MyConstraint myConstraint) {
        this.valueFromAnnotation = myConstraint.value();
    }

    @Override
    public boolean isValid(final String valueFromUser, final ConstraintValidatorContext context) {
        final boolean isValid = /* function(valueFromAnnotation, valueFromUser) */;
        return isValid;
    }
}
```

Аргумент типа `ConstraintValidatorContext` позволяет изменять стандартное флоу валидации, изменяя сообщения провала валидации, добавляя дополнительные `ConstraintViolation` и прочее.
В тривиальных реализациях валидаторов этот аргумент обычно не используется.

<mark>Можно ли кидать бизнесовые исключения в методе `isValid()`?</mark>

<mark>А как создавать ограничения на обобщенные типы?</mark>

---
## `ConstraintViolation`

При валидации объекта на соответствие ограничениям возвращается множество объектов, реализующих интерфейс `ConstraintViolation`.
```java
Set<ConstraintViolation<User>> violations = validator.validate(user);
```

Каждый `ConstraintViolation` - это нарушение какого-либо ограничения.

После получения множества ограничения их хотелось бы каким-то образом обработать.
Например, в веб-приложении можно вывести пользователю информацию о том, какие поля он заполнил неверно.
Для получения деталей нарушения ограничения интерфейс `ConstraintViolation` предоставляет множество методов:
- `String getMessage()` - возвращает сообщение о нарушении
- `String getMessageTemplate()` - возвращает шаблон, по которому было сформировано сообщение. Чаще всего это ключ сообщения в properties-файле
- `T getRootBean()` - возвращает объект, по которому было обнаружено нарушение.
- `Path getPropertyPath()` - возвращает путь до значения в валидируемом объекте, в котором было найдено нарушение
- другие

<mark>Лучше переделать тупое перечисление методов на осмысленный текст</mark>

### `Path`

`Path` - это путь до значения, по которому была провалена валидация.

Путь представляет собой коллекцию узлов <mark>TODO</mark>


---
## Группы валидации

Иногда при работе с валидацией значений приходится сталкиваться с тем, что какие-то значения нужно валидировать в одном случае и не нужно в другом.
Такая необходимость часто возникает во входных точках приложения, которые используются пользовательским интерфейсом. 
Например, в пользовательском интерфейсе может быть большая форма, некоторые поля которой нужно заполнять, только если заполнены другие.
Группы валидации были добавлены специально для того, чтобы дать такую возможность.

Разработчики Bean Validation могли бы сделать группы обычными строками, но для обеспечения типобезопасности и возможности наследования одних групп от других, группы были сделаны интерфейсами.

Для создания своей группы валидации нужно просто-напросто создать маркерный интерфейс.
```java
public interface AlienGroup { }
```

Рекомендаций по наименованию групп не существует, но лучше придерживаться в своих проектах какого-то одного стиля.
Например, добавлять суффикс `Group` или `Checks`.

В Bean Validation существует всего одна предопределенная группа валидации - `Default`. 
Именно она используется при валидации, если не указаны другие группы.
Все валидирующие аннотации, в которых не определены группы тоже считаются относящимися в группе `Default`.
По сути запись 
```java
@NotNull String name;
```
эквивалентна записи
```java
@NotNull(groups = Default.class) String name;
```

### Использование групп валидации

Если в классе есть поля, которые нужно валидировать только при определенных условиях, то для них нужно указать группу валидации с помощью атрибута `groups` валидирующей аннотации:
```java
class User {
	  @NotNull private final String name;
	  @NotNull @Email	private final String email;
	  @NotNull(groups = AlienGroup.class) private final String visa;
}
```

Теперь при обычном запуске валидатора поля `name` и `email` будут проверяться, а поле `visa` нет.
Потому что по умолчанию валидатор проверяет только те ограничения, которые относятся к группе `Default`.

Чтобы проверить поля, относящиеся к группе `AlienGroup` нужно при запуске валидатора в метод `validate()` передать в класс группы:
```java
final User user = new User( null, "invalid_email", "0123456789" );
final Set<ConstraintViolation<User>> violations = validator.validate( user, AlienGroup.class );
```
При этом никакие другие ограничения проверяться не будут.

Чтобы проверить ограничения, не относящиеся ни к какой кастомной группе, нужно при запуске валидатора передать еще и класс группы `Default`:
```java
final User user = new User( "Josh", "josh.long@pivotal.com", "0123456789" );
final Set<ConstraintViolation<User>> violations = validator.validate( user, AlienGroup.class, Default.class );
```

<mark>А как автоматически выбирать группу валидации в зависимости от заполненности полей? См. rdksmblid</mark>

### Наследование групп

Благодаря тому что группы представлены интерфейсами, можно выстраивать целые иерархии групп.
Например, можно унаследовать свою группу от `Default`:
```java
public interface AdultGroup extends Default { }
```

```java
class AdultUser extends User {
	@Min( value = 18, groups = AdultGroup.class ) private final int age;
  /* constructor, getter */
}
```

Тогда при проверке соответствия ограничениям не нужно будет дополнительно указывать дефолтную группу. Будут проверены и поля, относящиеся к указанной группе и к дефолтной:
```java
final AdultUser user = new AdultUser( "Josh", "invalid email", null, 17 );
final Set<ConstraintViolation<AdultUser>> violations = validator.validate( user, AdultGroup.class );
```

### Порядок проверки групп

Иногда требуется задать порядок проверки аннотаций. 
Чаще всего такая потребность возникает в двух случаях:
1. Если какое-то ограничение не прошло проверку, то проверка связанных с ним ограничений просто не имеет смысла.
2. Проверка некоторых ограничений может занимать длительное время, например из-за необходимости сходить в базу данных или обратиться к удаленному сервису. Если были найдены ошибки форматно-логического контроля, то выполнять дорогостоящие операции уже не имеет смысла.

Для того чтобы задать порядок проверки групп, нужно создать еще одну группу, на которую повесить аннотацию `@GroupSequence`. Группы будут валидироваться в соответствие с тем порядком, в котором они перечисленны в аннотации.
```java
@GroupSequence({ Default.class, DatabaseChecks.class, RemoteServicesChecks.class })
public interface OrderedChecks { }
```

Если будут обнаружены нарушения ограничений из первой группы, то проверки по другим группам даже не будут вызываться.
```java
Set<ConstraintViolation<AdultUser>> violations = validator.validate( user, OrderedChecks.class );
```

<mark>Во сколько потоков осуществляется проверка? Если есть обращения к внешним сервисам или к базе, хотелось бы чтобы они происходили в несколько потоков</mark>

#### Переопределение дефолтного порядка проверки групп

У аннотации `@GroupSequence` есть еще одна функция: она позволяет переопределить дефолтный порядок проверки групп, если поставить ее над классом валидируемого объекта.
```java
@GroupSequence({ Cat.class, DatabaseChecks.class, RemoteServicesChecks.class })
public class Cat {
    /* */
}
```

Так как создавать зацикленные порядки нельзя, то в `@GroupSequence` над классом нельзя указать группу `Default`. 
Чтобы при этом аннотации с дефолтной группой все равно провалидировались, нужно указать в `@GroupSequence` сам класс.

Очень часто эта фича используется для того чтобы проверки значений отдельных полей запускались перед проверками над классом.

Существует возможность динамически выстраивать порядок и состав групп, но это не является стандартной возможностью библиотеки, а обеспечивается Hibernate Validator. <mark>Дописать, когда будет необходимость</mark>

---
## Интеграция со Spring

<mark>Вынести в отдельную заметку</mark>

С помощью Bean Validation можно валидировать данные, приходящие из REST-контроллеров в аргументы методов, помеченных `@RequestParam` и `@PathVariable`.

Для того чтобы валидация начала работать необходимо над классом контроллера поставить аннотацию `@Validated`.

```java
@RestController
@Validated
public class AgentController {

    @GetMapping("/agent/basic-info")
    public List<AgentBasicInfo> basicInfo(
        @RequestParam(name = "referral_hash") @NotEmpty final List<String> agentsHashes,
    ) {
        /* */
    }
}
```

---
## Подключение зависимости

Сама по себе библиотека Bean Validation использоваться не может, поэтому в `pom.xml` нужно добавить зависимость какой-либо ее реализации. 
Например, `hibernate-validator`:
```xml
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>${hibernate-validator.version}</version>
</dependency>
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>jakarta.el</artifactId>
    <version>${jakarya.el.version}</version>
</dependency>
```
Библиотеку `jakarta.el` нужно подключить для того, чтобы обрабатывать EL-выражения.

В Spring Boot приложениях достаточно добавить одну зависимость: `spring-boot-starter-validation`.

---
## Идеи

Даже если правило валидации какого-либо поля очень простое, в интересах переиспользования лучше создать отдельную аннотацию.
Тогда при изменениях в правилах валидации нужно будет изменить код только в одном месте.
Если в проекте микросервисная архитектура, то возможно стоит вынести эти правила валидации в отдельную библиотеку (возможно прикопать их в ту же библиотеку, где объявлены переиспользуемые DTO).

Валидаторы на класс должны проверять соответствие только тем ограничениям, которые определяются совокупностью нескольких параметров класса. 
Не стоит в том же валидаторе проверять то, что можно проверить отдельно.

Стоит подумать над тем, чтобы добавить аннотацию `@Enum`, которая проверяет, что пришедшая строка (из json) соответствует хотя бы одному из значений перечисления.
Возможно это нужно добавлять не сюда, а куда-то на стык с Spring MVC и Jackson.

Аннотация `@Length` из hibernate-validator является менее мощным вариантом аннотации `@Size`. 
Так что стоит объявить ее deprecated.

Можно создать курс по Bean Validation. 
В нем последовательно знакомить слушателей с разными концепциями и особенностями
- Валидация небольшого DTO с использованием стандартных аннотаций
- Разные виды простановки валидаторов
  * На поле
  * На геттер
  * На класс
  * На типы в контейнерах (`Optional`, `List`, etc.)
  * Валидация типов в кастомных контейнерах с использованием экстракции данных (возможно нужно давать это чуть позже остального)
- Создание собственных ограничений
  * Ограничение на обычное значение
  * Ограничение на обобщенные типы
  * Композитные ограничения
- Наследование ограничений. Простановка ограничений на интерфейсах
- Каскадная валидация (с помощью `@Valid`)
- Сообщения о провале валидации
  * Получение сообщения об ошибке из properties-файла
  * Локализация сообщений об ошибках
- Группы валидации
- Создание валидатора для PbC
- ...
- Интеграция с JPA
- Интеграция со Spring

На [сайте Bean Validation](https://beanvalidation.org/2.0/) указано, что версию 2.0 стандарта поддерживает только Hibernate Validator, хотя в [гитхабе проекта Apache BVal](https://github.com/apache/bval) написано, что они тоже поддержали JSR 380

Класс `NodeImpl` написан с нарушением принципа подстановки Барбары Лисков и вообще его хочется переделать на рекорд.

---
## К изучению
- [ ] Официальная документация: https://beanvalidation.org/
- [X] Github страничка Hibernate Validator: https://github.com/hibernate/hibernate-validator/
- [X] Курс Spring & Hibernate for Beginners на Udemy
- [X] Интеграция Bean Validation и спринговых Rest-контроллеров: https://www.baeldung.com/spring-validate-requestparam-pathvariable
- [ ] Документация на спринговую валидацию: https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#validation
- [X] Устаревшая статья с множеством ошибок: https://habr.com/ru/post/424819/
- [X] Статья про Bean Validation и его интеграцию со Spring Boot: https://habr.com/ru/post/536612/

## Интересные ресурсы:

- Форум Hibernate Validator: https://discourse.hibernate.org/c/hibernate-validator/7