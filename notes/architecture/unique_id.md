---
title: "Уникальный идентификатор"
tags:
  - distributed_system
draft: false
---

# Уникальный идентификатор

Уникальные идентификаторы нужны для однозначного определения каждой сущности в информационных системах.

Существует несколько подходов к генерации уникальных идентификаторов:
- инкрементальная генерация - существует единый источник, генерирующий идентификаторы последовательно: `1234 1235 1236 ...`
- рандомная генерация - идентификатор генерируется рандомно, уникальность не гарантирована. Для уменьшения вероятности коллизий необходимо, чтобы максимальная емкость существенно превышала планируемое количество сущностей.
- генерация на основе времени - одной из частей идентификатора является текущая метка времени, другая часть обеспечивает уникальность в интервале дискретности метки времени


### Уникальность в распределенных системах
Одной из проблем является: как обеспечить уникальность идентификаторов в распределенных системах?
В централизованных системах генерация идентификаторов может быть поручена узлу системы, который существует в единственном экземпляре. 
Очень часто для этого используются сиквенсы в базе данных.
При записи новой сущности в базу, БД возвращает сгенерированный идентификатор.
Но что делать, если система не имеет единой точки синхронизации, например если она развернута на нескольких ЦОДах?

В этих случаях в состав идентификатора может быть включена метка, обозначающая ЦОД.
Если идентификаторы генерирует сервис, который может быть развернут в нескольких инстансах даже на одном ЦОДе, то в идентификатор можно включить еще и метку, определяющую конкретный инстанс сервиса.

### Защита от сдвига времени назад
В связи с особенностями функционирования [алгоритма синхронизации времени](distributed_systems_time.md) с NTP-серверами в некоторых случаях время в операционной системе может скакнуть на несколько секунд назад.

Если в системе используется алгоритм генерации на основе временных меток, то из-за сдвига системного времени назад могут возникнуть коллизии.
Уберечься от этого можно несколькими способами:
- хранить в памяти значения счетчиков за столько предыдущих меток времени, на сколько может быть сдвинуто назад время.
- при каждой генерации проверять текущую метку времени против последней использованной. Если она меньше предыдущей, значит системное время прыгнуло назад, и во избежание коллизий нужно бросить исключение.

Первый способ влечет за собой потребление памяти приложением, но позволяет сервису работать непрерывно. 
При втором способе сервис перестанет генерировать идентификаторы пока системное время не догонит предыдущее значение и будет отвечать ошибками.


## Популярные алгоритмы

### UUID

[UUID](../common/uuid.md) - популярный алгоритм генерации 128-битного уникального идентификатора.
Имеет несколько версий (номер версии отражен в самом идентификаторе)
Сейчас самой распространенной версией UUID является 4, которая генерирует полностью рандомное значение.
В самой популярной библиотеке для PHP долгое время существовал баг, который существенно увеличивал вероятность коллизии.


### Snowflake id
Система генерации уникальных идентификаторов, разработанная в Twitter в 2010 г.
Первоначально Twitter генерировал идентификаторы с помощью сиквенса в MySQL, но с развитием продукта они перешли на Cassandra и встали перед необходимостью самостоятельно генерировать ключи.
Также Twitter искал способ каким образом можно упорядочить твиты по времени без введения отдельного поля с меткой времени.
Для генерации идентификаторов было написано отдельное серверное приложение, которое может быть развернуто в виде кластера, отслеживаемого с помощью Apache Zookeeper.

Идентификаторы задаются с помощью 64-битного числа:
```
[     ] [timestamp millis] [node id] [sequense number]
[1 bit] [     41 bits    ] [10 bits] [    12 bits    ]
```
Идентификатор разбит на 3 группы (+1 на первый бит):
- Первый бит оставлен незаполненным, чтобы в системах с `signed int64` идентификатор не отображался в виде отрицательного числа;
- `timestamp millis` - временная метка в миллисекундах. Т.к. количество бит меньше стандартного для timestamp (64 бит), разработчикам пришлось сдвинуть нулевую отметку времени ближе к современности;
- `node id` - идентификатор ноды, сгенерировавшей идентификатор;
  - 5 бит на идентификатор ЦОДа
  - 5 бит на идентификатор ноды в ЦОДе
- `sequense number` - порядковый номер сущности, инкрементирующийся в пределах одной миллисекунды для заданной ноды.

Подобный подход позволяет генерировать с помощью одной ноды 4096 идентификаторов в миллисекунду.

При превышении максимального значения счетчика сервис не кидает ошибку, а ожидает наступления следующей миллисекунды. 
Такое поведение приемлимо, когда единица дробления - миллисекунды. Т.к. сетевые издержки на ретраи превысят время блокировки на сервере генерации идентификаторов.

Уникальность значения `node id` между различными инстансами отслеживается с помощью ZooKeeper.


### Instagram id
Instagram вдохновлялся примером Twitter в части структуры идентификатора.
Но разработчики не хотели держать отдельную группу сервисов, для которых нужно поддерживать Service Discovery.
Поэтому они использовали для генерации сиквенсов хранимую процедуру в Postgres.
А, для того чтобы иметь возможность генерировать уникальные id в разных ЦОДах и на разных шардах, использовали фичу Postgres - схемы (внутреннее шардирование таблицы внутри одного инстанса Postgres).

Сам идентификатор разбит на 3 группы:
```
[timestamp millis] [shard id] [sequense number]
[     41 bits    ] [13 bits ] [    10 bits    ]
```


### ULID
ULID - это развитие идей, заложенный в UUID.
ULID состоит из двух частей:
- 48 бит на метку времени
- 80 бит на рандомную часть

ULID кодируется с помощью алфавита Base32 и потому в строковом представлении занимает 26 символов


### KSUID
K-Sortable Unique Identifier
KSUID состоит из двух частей:
- 32 бит на метку времени с шагом в 1 секунду
- 128 бит на рандомную часть

Итого 160 бит, что больше остальных решений.

KSUID кодируется с помощью Base62 в 27 символов.


### Flake
Flake - это еще одно серверное решение, вдохновленное Snowflake Id.
В отличие от Snowflake Flake не требует дополнительного координатора для выбора идентификатора ноды.
Идентификатором ноды является MAC-адрес сервера.

Flake состоит из трех частей:
- 64 бит на метку времени с шагом в миллисекунду
- 48 бит на идентификатор ноды. Для этого используется MAC-адрес узла
- 16 бит на порядковый номер в пределах одной миллисекунды

Flake подходит только для разворачивания на железных серверах, т.к. он завязан на MAC-адрес.


### Проблема раскрытия внутренней реализации
Если в идентификаторах прослеживается какая-то логика, то это может дать некоторую информацию злоумышленникам.

Помню, как я удачно реверс-инжинирнул идентификаторы в популярной социальной сети и смог зайти в закрытые ресурсы одного человека.
Не помню точно, но возможно это были альбомы с фотографиями.
Все из-за того, что альбомы скрывались от посторонних глаз при запросе всех альбомов конкретного человека, но обнаружив дырку в их идентификаторах, можно было зайти в этот альбом, т.к. проверки доступа не было.

Было это устроено приблизительно так.
На запрос всех альбомов приходил ответ с их идентификаторами
```
https://socnet.com/id5555/album
```

```json
[
  {
    "album_id": "1",
    "pictures": [
        "https://socnet.com/picture/123000",
        "https://socnet.com/picture/123001",
    ]
  },
  {
    "album_id": "3",
    "pictures": [
        "https://socnet.com/picture/456000",
        "https://socnet.com/picture/456001",
    ]
  }
]
```

После чего можно было войти в альбом, который был скрыт
```
https://socnet.com/id5555/album/2
```

Заметьте, что никакой информации о втором альбоме не было в ответе на первый запрос. 
Но отсутствие информации само по себе стало информацией.

Таким недостатком обладают индентификаторы с инкрементальной генерацией и с генерацией на основе времени.
Для того чтобы ликвидировать эту уязвимость можно либо использовать идентификаторы с рандомно генерируемой частью, либо изменять идентификаторы с возможностью обратной конвертации.
Например, идентификатор, который сгенерирован базой данных может быть преобразован при отдаче данных с сервера `123456 -> f8S12`, а при получении запросов с клиента, преобразован в обратную сторону `f8S12 -> 123456`.
Для этих целей может использоваться, к примеру, библиотека `hashids`, о которой ниже.

### Hashids
<mark>todo</mark>


### Сравнение популярных способов генерации

| Способ генерации | bits | symbols | sortable | lib or app |
|---|---|---|---|---|
| UUID | 128 b | 36 | no | lib |
| Snowflake | 64 b | | yes | app |
| Instagram Id | 64 b | | yes | app |
| ULID | 128 b | 26 | yes | lib |
| NanoId | 126 b | 21 | no | lib |
| KSUID | 160 b | 27 | yes | lib |
| Flake | 128 b | 18 | yes | app | 
| Hashids | | | no | lib |


## Размышления

Что хотелось бы видеть в самописном генераторе идентификаторов:
- таймстемп
- уникальный идентификатор генератора. Может состоять из нескольких частей, чтобы разбивать ноды на группы
- уникальный номер в рамках одного генератора и шага таймстемпа
- номер версии формата идентификатора на случай, если он будет развиваться


---
## К изучению
- [X] [UUID wiki](https://en.wikipedia.org/wiki/Universally_unique_identifier)
- [X] [История UUID](https://segment.com/blog/a-brief-history-of-the-uuid/)
- [X] [Snowflake Id](https://en.wikipedia.org/wiki/Snowflake_ID). [Исходный код](https://github.com/twitter-archive/snowflake/tree/scala_28) серверного решения. [История появления](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake)
- [X] [Уникальные Id в Instagram](https://instagram-engineering.com/sharding-ids-at-instagram-1cf5a71e5a5c)
- [X] [Уникальные Id на стороне клиента в Firebase](https://firebase.blog/posts/2015/02/the-2120-ways-to-ensure-unique_68)
- [X] [ULID](https://github.com/ulid/spec)
- [X] [KSUID](https://github.com/segmentio/ksuid)
- [X] [Flake](https://github.com/boundary/flake). [История появления](https://archive.ph/2015.07.08-082503/http://www.boundary.com/blog/2012/01/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/)
- [ ] [NanoId](https://github.com/ai/nanoid) и его [использование в PlanetScale](https://planetscale.com/blog/why-we-chose-nanoids-for-planetscales-api)
- [ ] [HashIds](https://hashids.org/)
- [X] [Коллизии в популярной библиотеке для генерации UUID для PHP](https://github.com/ramsey/uuid/issues/80) (fixed)