---
title: "Консенсус"
tags:
  - distributed_system
draft: false
---

# Консенсус

Очень часто в распределенных системах для [броадкастинга](broadcasting.md) используется схема с единственным лидером.
Если этот лидер откажет или станет недоступным, то система должна выбрать среди оставшихся нод нового лидера.
Для этого то как раз и нужны алгоритмы консенсуса.

- Paxos - алгоритм консенсуса для единственного значения
- Multi-paxos - алгоритм консенсуса для списка значений
- Raft - дальнейшее развитие Paxos, устранившее его недостатки
- Viewstamped replication - 
- Zab - Zookeeper Atomic Broadcast 

Все алгоритмы консенсуса применимы только к частично синхронным fail-recovery [распределенным системам](distributed_system.md).
Существует теорема FLP (Fischer, Lynch, Paterson), которая гласит, что в асинхронных fail-stop системах консенсус невозможен.

Существуют алгоритмы консенсуса для частично синхронных систем с византийскими нодами.
Они используются преимущественно в блокчейне.

Алгоритм консенсуса должен:
- определять падение лидера
- выбирать нового лидера
- не допускать одновременного появления нескольких лидеров (split-brain)

## Raft
<mark>todo вынести в отдельную заметку</mark>

В Raft есть понятие сессии голосования.
Лидер избирается на одну сессию.
Каждый раз при смене лидера номер сессии инкрементируется.
При выборах каждая нода имеет только один голос.
Для выбора лидера в кластере должен соблюдаться [кворум](replication.md).

Допустим в системе был лидер и он отвалился из-за проблем со связью.
Кластер избрал нового лидера.
Вдруг связь восстанавливается и первый лидер возвращается в кластер.
В системе оказалось два лидера.
Но один был выбран в сессии `T`, а второй в сессии `T + 1`.

Перед доставкой каждого сообщения лидер должен опросить ноды в кластере считают ли они его до сих пор лидером. Только после получения акновледжей он может броадкастить сообщение.

Состояние ноды в кластере описывается конечным автоматом:
- подписчик
- кандидат
- лидер

При старте нода принимает состояние подписчик.
Если она подозревает, что лидер сдох, то становится кандидатом.
Если за кандидата проголосовал кворум, то он становится лидером.
Если кандидат видит, что появился новый лидер, то он становится подписчиком.
Лидер становится подписчиком, если узнает, что появился новый лидер с большим порядковым номером сессии.

У каждой ноды должен быть набор параметров для реализации алгоритма.
Часть из них должны быть персистентными, а часть может храниться в памяти.
Персистентными должны быть:
- номер текущей сессии
- за кого голосовала эта нода (или null)
- лог сообщений
- длина коммита ???

Лог сообщений - это массив пар сообщение - номер сессии.

При получении сообщения лидер рассылает свой лог остальным нодам в кластере.
Периодически лидер должен реплицировать лог на остальные ноды даже если новых сообщений не поступало.
Такая периодическая репликация может служить хартбитом.

Функцию, которую вызывает лидер для доставки сообщений на конкретную ноду-подписчика, принято называть `ReplicateLog()`.
В этой функции лог сообщений разбивается на две группы: префикс и суффикс.
Префикс - это сообщения, которые были отправлены на ноду подписчика ранее, суффикс - это новые сообщения.
Если суффикс пустой, то данное сообщение является хартбитом.

### Использование Raft
Raft используется в таких системах как:
- ScyllaDB
- Aeron
- [Hazelcast](../external_lib/hazelcast.md) начиная с версии 3.12
- RabbitMQ
- Redis
- многие другие


---
## К изучению
- [X] [6 лекция](https://www.youtube.com/watch?v=rN6ma561tak&list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB&index=18&t=1s) курса по распределенным системам от Мартина Клеппманна
- [ ] [Raft. Официальная страничка](https://raft.github.io/) с описанием алгоритма, анимированной визуализацией и списком популярных реализаций на разных языках