---
title: "Репликация"
tags:
  - database
  - distributed_system
draft: false
---

# Репликация

**Репликация** - это хранение копии данных на нескольких нодах системы.
Нода, на которой хранятся копии, называется __репликой__, а основная нода, на которую изначально происходит запись данных и откуда данные копируются на реплики, называется __ведущей (master/leader)__.
Репликация используется для того чтобы при отказе одной из нод, данные не были потеряны.
Также репликация может использоваться для хранения данных ближе к клиентам, их запрашивающим.

Репликация используется в:
- базах данных
- файловых системах
- кэшах
- и т.д.

Репликация отличается от RAID массивов тем, что с репликами можно взаимодействовать независимо от мастер-ноды.
Также реплики могут располагаться в разных датацентрах очень далеко друг от друга.

В разных системах используются различные архитектурные подходы к репликации:
- с одним ведущим узлом
- с несколькими ведущими узлами
- без ведущих узлов

Репликация может выполняться синхронно или асинхронно:
- Синхронная репликация - при записи на ведущую ноду, запись не будет считаться завершенной, пока данные не отреплицируются на синхронные реплики.
- Асинхронная репликация - при записи ведущая нода не ждет, пока данные отреплицируются, и возвращает поток управления клиенту. Данные отреплицируются отдельным независимым процессом.

В различных базах данных как правило можно настроить вид репликации для различных реплик. 
Например, в [Kafka](../tools/kafka.md) можно выбрать количество _InSync_ реплик.


### Проблемы репликации

Если на одной реплике есть данные, а на другой их нет, то возникает двоесмыслие:
- либо данные не доехали до реплики, где их нет
- либо реплика, где данные есть, не получила запрос на их удаление

Для того чтобы побороть эту проблему, для каждой записи стараются добавлять отдельное поле (колонку), в которой указывается таймстэмп последнего изменения данных.
При этом данные при удалении не удаляются полностью, а только помечаются как удаленные. 
Такие данные на сленге называются "надгробными камнями" (tombstone).
То есть для каждой записи должно быть два поля: `update_timestamp` и `is_terminated`.
Благодаря этому при расхождении данных между репликами (например после сплит-брейна) их можно будет уверенно смержить.

Так как время между нодами может [разъезжаться](distributed_systems_time.md), то вместо таймстемпов в UNIX time лучше использовать логические часы.
При использовании [часов Лэмпорта](../algorithms/lamport_clock.md) останутся только те данные, которые имеют большее значения счетчика.
При использовании [векторных часов](../algorithms/vector_clock.md)) останутся события с большим значением счетчика при наличии причинности, и все варианты события, если эти варианты являются конкурентными.

## Кворум

**Кворум** - минимальное количество работающих нод, которое необходимо, чтобы гарантировать актуальность данных.

Для того чтобы клиент мог записать и прочитать самые актуальные данные, необходимо чтобы выполнялось условие
```
read_count + write_count > total_count
```
То есть множество нод, доступных на запись, должно иметь хотя бы одно пересечение со множеством нод, доступных на чтение.

Если клиент, читая данные из нескольких нод, замечает неконсистентность, то он может отправить запросы на обновление данных в ноды с устаревшим состоянием.

Скорее всего именно по этому такие распределенные системы, как [Hazelcast](../external_lib/hazelcast.md) и [Kafka](../tools/kafka.md) распространяются вместе со своими клиентскими библиотеками.
Кажется, что в эти клиентские библиотеки должна быть встроена работа с логическими часами и с обновлением устаревших данных.


## Способы репликации

Репликация может быть построена на одном из видов [броадкастинга](broadcasting.md)/

| броадкастинг | Допущения |
| --- | --- |
| FIFO Total order | Детерминированность обновлений |
| Causal | Детерминированность обновлений, конкурентные обновления коммутативны (`f(g(x)) = g(f(x))`) |
| Reliable | Детерминированность обновлений, все обновления коммутативны |

### State machine replication
State machine replication - это способ репликации, при котором:
- Репликация проводится с помощью FIFO Total Order броадкастинга
- Реплика, передающая сообщение об обновлении, применяет его к своему состоянию
- Обновление реплик детерминировано (т.е. если к репликам, находящимся в одном состоянии придет одинаковое сообщение об обновлении, то они всегда перейдут в одинаковое состояние)


---
## К изучению

- [ ] Книга. Martin Kleppmann. Designing data-intensive applications. Глава 5
- [X] [5 лекция](https://www.youtube.com/watch?v=mBUCF1WGI_I&list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB&ab_channel=MartinKleppmann) курса по распределенным системам от Мартина Клеппманна