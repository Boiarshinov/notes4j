---
title: "Идемпотентность"
tags: 
  - patterns
draft: false
---

# Идемпотентность

Выражаясь математически, идемпотентность - это свойство операции, при котором ее многократный вызов возвращает тот же результат, что и однократный.
```
f(f(x)) = f(x)
```

Для компьютерных систем идемпотентность - это полезное свойство, обеспечивающее предсказуемость выполнения операций.

Предположим, что ваш сервис занимается переводом денег со счета на счет. 
Сервис предоставляет функцию 
```
move_money(from, to)
```
Функция полезная, и не исключены случаи, когда она будет вызываться несколько раз подряд с одними и теми же параметрами.
Но из-за сетевых сбоев и ошибок на стороне клиента функция может быть вызвана несколько раз непреднамеренно.
Чтобы этого избежать, необходимо отделять между собой задублированные запросы и последовательные вызовы с одинаковыми параметрами.
Для этого в параметры запроса добавляется **ключ идемпотентности**.
```
move_money(from, to, idempotency_key)
```

Дедупликация происходит по этому ключу.

Ключ идемпотентности может быть как суррогатным, так и натуральным.
Суррогатный - созданный специально для целей дедупликации.
Натуральный - один из параметров исходного запроса, который точно должен быть уникальным для каждого вызова.


## Идемпотентность в HTTP
В стандарте на [HTTP](../network/http.md)/1.1 RFC-2616 рекомендуется всегда соблюдать идемпотентность для методов `GET`, `HEAD`, `PUT`, `DELETE`.

С `GET` и `HEAD` все просто - как правило они не меняют состояние на сервере, а значит идемпотентность будет обсепечиваться автоматически.
Конечно, их вызов может вызывать изменения в системе, например, данные могут быть помещены в кэш. Но такие изменения не влияют на состояние системы со стороны внешнего наблюдателя.
Т.е. для `GET` и `HEAD` чаще всего действует еще более строгая гарантия:
```
f(x) = x
```
, где x - это состояние системы.

`DELETE` удаляет ресурс, после чего все последующие попытки его удаления будут приводить к ошибке - ресурс не найден.

`PUT` тоже меняет состояние ресурса однократно, а все последующие вызовы с теми же параметрами ничего не изменят, т.к. ресурс уже находится в желаемом состоянии.

Для всех вышеописанных методов можно написать серверный код так, что идемпотентность не будет соблюдаться.
Но, как правило, фреймворки не дадут вам допустить такую ошибку.

Для `POST` без специальных ухищрений идемпотентность не соблюдается.
Если вы создаете ресурс, то повторные попытки создания будут порождать все новые и новые ресурсы.
Такое поведение может приводить к печальным последствиям, если повторный вызов был совершен по ошибке или из-за сетевых сбоев.
Деньги могут списаться дважды, или будет дважды заказана какая-то услуга.
Для того чтобы такого не происходило, и повторный `POST` с теми же параметрами не порождал новой сущности, необходимо дедуплицировать запросы.
Дедуплицировать можно по какому-либо набору полей из входных данных, но лучше всего завести специальное поле - **ключ идемпотентности**.

Ключ идемпотентности генерирует клиент и помещает его в какую-либо часть HTTP-запроса.
Лучше всего для этого подходит заголовки, т.к. ключ идемпотентности - это мета-информация.
Но при желании, можно поместить его и в тело.
Например, ключом идемпотентности может являться идентификатор сущности в системе клиента, и тогда его логично запихнуть в тело, т.к. этот идентификатор является одним из полей сущности.


## Цена идемпотентности



---
## К изучению

- [X] Великолепная [статья об идемпотентности](https://habr.com/ru/company/yandex/blog/442762/) от Яндекса
- [X] [Об идемпотентости HTTP методов в RFC](https://datatracker.ietf.org/doc/html/rfc2616#section-9.1.2)