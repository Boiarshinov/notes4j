---
title: "Architecture concepts"
tags: 
  - architecture
draft: true
---

# Архитектурные подходы

В современном видении принято выделять несколько основных подходов к архитектуре приложений:
- Монолитная архитектура
- Сервис-ориентированная архитектура
- Микросервисная архитектура

---
## Монолитная архитектура
Это основа основ.
Есть единое приложение, которое интегрируется только с внешними системами и стандартными подсистемами (базами данных, кэшами и т.д.).

![monolithic](../../images/src/arch_monolith.drawio.svg)

В web'е монолит изначально сам занимался составлением html.
В какой-то момент приложения все же разделились на frontend и backend, но backend продолжили называть монолитом.

![monolithic_frontend_backend_separated](../../images/src/arch_monolith_separated.drawio.svg)

С развитием продуктов в интернете стало понятно, что монолитная архитектура плохо масштабируется: большое количество разработчиков начинают мешать друг другу, изменения в одних частях системы приводят к сбоям в других частях, релизить часто - сложно, а для того чтобы релизить реже, необходимо координировать выпуск нескольких часто независимых фичей.

Эту проблему пытались решить разными способами.
Один из них - это __модульный монолит__.
В модульном монолите различные подсистемы разносятся по отдельным пакетам или модулям.
В экосистеме Java это могут быть отдельные модули, которые будут подключаться к общему монолиту как зависимости (jar-файлы).

---
## Сервис-ориентированная архитектура
В 00-х годах придумали подход, названный сервис-ориентированной архитектурой.
В этом подходе приложение дробится на отдельные части. 
С их помощью можно как из кубиков собирать различные продукты.
Продукт - это верхнеуровневый сервис, осуществляющий координацию остальных сервисов.
При этом сервисы общаются между собой с помощью шины данных, часто называемой ESB - Enterprise Service Bus.

![SOA](../../images/src/arch_soa.drawio.svg)


---
## Микросервисная архитектура
Сервис-ориентированная архитектура во многом была завязана на тяжеловесные продукты с дорогими лицензиями.
С развитием open-source'а появились бесплатные on-premise альтернативы, что привело к появлению микросервисной архитектуры.

В микросервисной архитектуре различные бизнес-домены выделяются в отдельные сервисы.
Микросервисы могут общаться друг с другом напрямую или через различные message broker'ы.
Как правило микросервисы не имеют разделяемых ресурсов, каждый из сервисов полностью сам отвечает за данные, с которыми он работает.

![MicroServices](../../images/src/arch_microservices.drawio.svg)

На стороне фронтенда также есть тенденция разбития монолитного фронтенда на микрофронтенды, которые могут выглядеть, например, как виджеты, подключаемые на общую страницу.


---
## Плюсы и минусы подходов
Почти всегда плюсы одного подхода - это решение минусов другого подхода.
И в обратную сторону: минусы одного подхода проявляются при переходе с другого подхода.

Плюсы монолита:
- отсутствие распределенных транзакций
- простота развертывания
- большая часть пользовательских сценариев обрабатывается в рамках одного процесса

Минусы монолита:
- конфликты кодовой базы при совместной разработке
- плохая техническая масштабируемость
- хрупкость
- сложность понимания

Плюсы микросервисов:
- изоляция команд разработки
- независимые релизы
- устойчивость к сбоям (но при этом возможны отказы по принципу домино)
- возможность выбора уникального технологического стека под задачу

Минусы микросервисов:
- сложно правильно декомпозировать бизнес-домен на микросервисы
- могут появиться распределенные транзакции
- дублирование данных
- разработчики одного сервиса не видят систему целиком
- большое количество интеграций между сервисами - необходимость отслеживать сбои, проводить service discovery и т.д.
- необходимость синхронизации команд разработки при работе над задачей, затрагивающей несколько сервисов


---
## К изучению
- [ ] ???

