---
title: "Время в распределенных системах"
tags: 
  - distributed_system
  - time
draft: false
---

# Время в распределенных системах

Распределенным системам постоянно приходится работать со временем:
- отложенные задачи, выполняемые по крону
- таймауты на ожидание ответа и на ретраи
- при записи или обновлении данных в БД записать текущее время
- запись времени при логировании
- определение последовательности событий


## Часы

<mark>Вынести в отдельную заметку</mark>

### Кварцевые часы
В современных компьютерах для определения времени используются кварцевые часы.
Они имеют погрешность, измеряемую в том на сколько микросекунд может отличаться их показания от эталонного за секунду.
Для текущего поколения кварцевых часов это составляет ~ 50 мкс / с.
На погрешность очень сильно влияет температура кварцевых часов, поэтому в серверных стойках стараются поддерживать постоянную температуру.

### Атомные часы
Атомные часы имеют гораздо большую точность.
Они построены на физическом свойстве Цезия-133.
Атомные часы стоят около 20'000$, что не очень дорого для хороших серверных центров.

### Разница между астрономическим и квантовым временем
Проблема в подсчете времени заключается в том, что астрономическое время (основанное на вращении Земли) не совпадает с квантовым.
Происходит это из-за того, что Земля вращается неравномерно.

- **GMT** - Greenwich Mean Time - астрономическое время. Основывается на том, что в 12 часов солнце должно быть ровно на юге на нулевом мередиане.
- **IAT** - International Atomic Time - время, основанное на атомных свойствах Цезия-133.
- **UTC** - Coordinated Universal Time - IAT с корректировкой на неравномерность вращения земли.

**Leap second** - корректировочная секунда, на которую могут быть откорректированы все мировые часы 30 июня или 31 декабря. 
Как в положительную сторону, так и в отрицательную.
На сколько и когда корректировать объявляется научным сообществом заранее.

## В компьютерах
В компьютерах время представляется одним из двух способов:
- Unix time - количество миллисекунд, прошедших с 1 января 1970 года 00:00:00 UTC. Без учета leap seconds.
- ISO-8601 - стандарт, по которому время представляется в формате `yyyy-MM-dd'T'HH:mm:ss.xxx +(-)UTC_offset`.

Весь софт игнорирует наличие leap seconds.

30 июня 2012 года из-за бага в Linux при переводе leap seconds многие приложения по всему миру зависли.
Даже перезагрузка не помогала.
В основном это [были](https://habr.com/ru/post/146863/) Java-приложения и MySQL сервера.

## Синхронизация часов
Для синхронизации часов между нодами распределенной системы каждая нода корректирует свои часы, обращаясь к специальному серверу с точными часами, например атомными.
Для такого обращения используется протокол **NTP** - Network Time Protocol.

Синхронизация времени по NTP входит во все популярные ОС по умолчанию. 
Например в Windows идет синхронизация с сервером `time.windows.com`.

NTP при хорошем интернет соединении позволяет получить точность синхронизации в пределах нескольких миллисекунд.

NTP клиент для синхронизации времени отправляет запрос, в котором содержится текущее время по его часам. 
NTP сервер отправляет ответ, в котором содержится время из запроса, время получения сообщения от клиента и время отправки ответа.
Когда клиент получит ответ, он может вычислить время, затраченное на передачу по сети, по формуле
```
networkDelta = (clientReceiveTime - clientRequestTime) - (serverResponseTime - serverReceiveTime)
```
Далее, предполагая, что сетевые издержки симметричны, можно вычислить на сколько нужно изменить текущие показания времени.

Если разница получилось небольшой (меньше ~ 100 мс), то ОС замедляет / ускоряет течение времени на какое-то время, чтобы погрешность выровнялась.
Если разница достигает 1 с, то ОС изменяет время скачком.
Если разница превышает 1 с, то ОС говорит, что у нее лапки, и в проблеме приходиться разбираться человеку.
Поэтому важно повесить мониторинг на взаимодействие вашего сервера с NTP сервисом.

Когда время изменяется скачком многие приложения могут охренеть от такого, например при вычислении длительности выполнения какой-нибудь функции.
Результат измерения может быть отрицательным!
Поэтому такие измерения должны быть основаны на монотонных часах.
В Java это
```java
long currentNano = System.nanoTime();
```

## Happens Before
Событие A happens before события B если
- события A и B произошли на одной ноде и событие A было раньше
- события A и B - это одно и то же событие, но событие A - это порождающее событие, а событие B - это уведомление о событии A, полученное другой нодой.
- существует событие C, которое произошло позже события A и раньше события B

События A и B могут быть между собой:
- A раньше B
- B раньше A
- A и B конкурентны, т.е. произошли на разных нодах и ничего не знают о друг друге.


## Логические часы
Логические часы - это часы, которые вместо подсчета времени считают количество событий.

- [Часы Лэмпорта](../algorithms/lamport_clock.md)
- [Векторные часы](../algorithms/vector_clock.md)

## К изучению

- [X] [3 лекция](https://www.youtube.com/watch?v=FQ_2N3AQu0M&list=PLeKd45zvjcDFUEv_ohr_HdUFe97RItdiB&index=8&ab_channel=MartinKleppmann) курса по распределенным системам от Мартина Клеппманна
- [ ] [Wiki - NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol)