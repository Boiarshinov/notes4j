---
title: "Transactional Outbox"
tags: 
  - architecture
  - pattern
draft: false
---

# Transactional Outbox

__Transactional Outbox__ - это паттерн гарантированной отправки сообщений в message broker с одновременной записью в БД.

Transactional Outbox решает следующую проблему: допустим сервис при получении запроса должен сохранить что-то в базе данных и опубликовать событие в очередь.
БД и брокер являются независимыми системами, между ними невозможно сделать общую транзакцию.

Если выполнять сохранение в БД и публикацию в очередь последовательно без дополнительных ухищрений, то невозможно гарантировать консистентность двух хранилищ.
Допустим мы публикуем событие после сохранения в БД.
В этом случае при сбое на стороне брокера событие не будет опубликовано.
Получится ситуация, когда мы выполнили запрос, создали, например какую-либо сущность, но при этом не оповестили об этом системы, которые должны выполнить свою часть работы.
В обратном случае, когда мы публикуем событие перед сохранением в БД получается ситуация еще хуже.
При сбое при сохранении в БД, мы отдадим клиенту, приславшему запрос, ошибку, ничего не сохраним, но при этом для других систем будет все выглядеть так, будто запрос был обработан успешно.

Для борьбы с этой проблемой придумали следующее решение.
При получении запроса событие не публикуется, но сохраняется в отдельную таблицу xxx_outbox в БД в той же транзакции, что и сохранение в основную таблицу.
Из-за использования транзакций и подхода к наименованию вспомогательной таблицы этот паттерн и носит название _transactional outbox_.
При этом отдельный процесс непрерывно читает эту таблицу и публикует свежие записи в message broker. 
При удачной публикации он помечает запись обработанной.

Если случится сбой при обновлении записи в таблице outbox, то это не приведет к каким-либо проблемам.
Процесс в очередной заход снова вычитает запись и повторно отправит ее в message broker.
Таким образом паттерн transactional outbox позволяет достичь гарантии __at least onse__.
Это значит, что подписчики данного вида события должны проводить дедупликацию на своей стороне.

Таблица Outbox может быть общей для разных типов событий:
```sql
create table outbox (
    id bigint auto_incremented primary key,
    inserted_at timestamp default now(),
    published_at timestamp comment 'Время отправки события в message_broker',
    aggregate_type varchar(100) comment 'тип сущности / события',
    aggregate_id varchar(100) comment 'идентификатор сущности, породившей событие',
    event_type varchar(100) comment 'тип события',
    payload blob comment 'данные события'
    -- надо продумать партиционирование таблицы, чтобы чистить старые данные
)
```

Еще один паттерн, которые решает эту проблему - это __CDC__ - change data capture.
В CDC разворачивается отдельный коробочный сервис (например, [Kafka Connect](../tools/kafka_connect.md) с определенным коннектором), который читает WAL основной таблицы и самостоятельно публикует события в message broker.
Иногда имеет смысл оставить вспомогательную таблицу, т.к. в нее записи только добавляются и не изменяются, что может быть проще для настройки CDC.
К тому же структура данных в таблице может быть специально адаптирована для публикуемых событий.

---
## К изучению
- [ ] [Transactional Outbox](https://microservices.io/patterns/data/transactional-outbox.html)
