---
title: "Gradle"
tags:
  - build
draft: false
---

# Gradle

## Общие сведения

Gradle - сборщик и менеджер зависимостей для программного обеспечения.
Gradle позволяет собирать приложения на любом языке, но особенно популярен он для проектов на JVM-based языках.

В Java мире Gradle борется за внимание разработчиков с [Maven](maven.md). 
Gradle работает быстрее Maven благодаря инкрементальным билдам, которые позволяют не выполнять различные таски, выполнявшиеся ранее.

Запуск задач Gradle можно производить с помощью IDE или CLI.
Вызов любой команды Gradle состоит из трех фаз:
- Инициализация - подготовка окружения к билду
- Конфигурация - строится граф тасок, определяется последовательность вызова тасок
- Выполнение - запускаются выбранные таски

Для отслеживания состояния билдов в Gradle есть специальный инструмент `build scans`.

Сборка проекта осуществляется в директорию `build`.

Gradle предоставляет возможно создавать различные задачи - таски и выстраивать их в графы зависимостей.

В Maven вся конфигурация прописывалась в одном файле - `pom.xml`. 
В Gradle же конфигурация распределена между несколькими файлами:
- `build.gradle(.kts)` - плагины, зависимости, таски конкретного модуля
- `settings.gradle(.kts)` - основная информация о проекте: его название, включаемые модули (если проект мультимодульный), настройка репозиториев
- `gradle.properties` - настройки gradle и константы, переиспользуемые в разных модулях (например, версии зависимостей)
- `libs.versions.toml` - версии зависимостей, плагинов
Описание процесса сборки проводится с помощью языков Groovy или Kotlin DSL.

Стандартные глобальные переменные:
- `project` - инстанс проекта
- `projectDir` - директория проекта
- `buildDir` - директория, в которую помещаются class-файлы и др. файлы, создающиеся при сборке проекта. Аналог `project.build.directory` из Maven.
- `path` - абсолютный путь к проекту

---
## Описание проекта
Описание проекта задается в файле `settings.gradle(.kts)`.
В нем устанавливается название проекта и все его подмодули:
```kotlin
rootProject.name = "my-project"

include("core")
include("api")
include("emulator")
```

Gradle будет пытаться найти в корне проекта директории с названиями указанных подмодулей, чтобы импортировать их.
Если нужно как-то подебажить gradle, обновить версию gradle wrapper и т.д., можно отключить обработку подмодулей, закомментировав их описание в `settings.gradle`.

Чтение `settings.gradle` происходит на этапе инициализации проекта (про этапы см. выше).
При инициализации Gradle создает объект класса `Settings`.
В нем задаются параметры `rootDir`, `rootProject`, `plugins` и т.д.
Файл `settings.gradle` по сути является отображением этого объекта, поэтому в нем можно обращаться к данным параметрам и конфигурировать их.

В `settings.gradle` зачастую описываются репозитории, из которых будут выкачиваться плагины и зависимости.
Также могут быть объявлены плагины, общие для всех подмодулей.
```kotlin
pluginManagement {
  repositories {
    gradlePluginPortal()
    mavenCentral()
  }
}

dependencyResolutionManagement {
  repositories {
    mavenCentral()
  }
}

plugins {
  id("my.cool.gradle.plugin") version "1.5.0"
}
```


---
## Зависимости
```kotlin
dependencies {
    implementation("org.jooq:joox:1.6.2")
    testImplementation("org.junit.jupiter:junit-jupiter:5.8.2")
}
```
Название зависимости состоит из 3 частей: пакет, артефакт и версия.

Подключить другой субпроект, находящийся в том же репозитории можно так:
```kotlin
implementation(project(":another-subproject-name"))
```

### Version Catalog
Version catalog - это файл `libs.versions.toml`, находящийся, как правило, в директории `/gradle` проекта, в котором описаны версии зависимостей и плагинов.

Файл разделен на секции:
- `[versions]` - версии плагинов и библиотек
- `[libraries]` - библиотеки
- `[bundles]` - множества зависимостей, объединенных чем-то общим
- `[plugins]` - плагины

```toml
[versions]
joox = "1.6.2"
junit = "5.8.2"

[libraries]
joox = { group = "org.jooq", name = "joox", version.ref = "joox" }
junit5 = { group = "org.junit.jupiter", name = "junit-jupiter", version.ref = "junit" }
```

На зависимости, объявленные в `libs.versions.toml`, затем можно ссылаться в `build.gradle` файлах по ключу с использованием префикса `libs`.
```kotlin
dependencies {
    implementation(libs.joox)
    testImplementation(libs.junit5)
}
```

### Изучение зависимостей
Иногда требуется узнать о своем проекте всю подноготную: 
- какие вообще зависимости в нем есть? 
- откуда транзитивно прилетела какая-либо библиотека?
- почему из двух версий одной библиотеки используется именно эта?

Для ответа на все эти вопросы в gradle есть специальные таски.
`dependencies` - печатает дерево зависимостей
`dependencyInsight` - показывает: откуда прилетела указанная зависимость

---
## Конфигурации

Конфигурация - это область видимости зависимости.
Какие-то зависимости должны быть видны только в тестах, какие-то только в рантайме.

Конфигурации могут быть объявлены как в самом build файле, так и подтянуться из плагинов.
Сужение конфигурации до минимально необходимой позволяет ускорить выполнение тасок и уменьшить размер classpath.

Стандартные конфигурации Java-плагина:
- `implementation` - зависимость, которая используется и при компиляции, и в рантайме.
- `api` - определена в java-library плагине. Зависимости, добавленные с помощью этой конфигурации будут транзитивно подтягиваться в проекты, которые объявили зависимость от библиотеки.
- `compileOnly` - зависимости, которые нужны только при компиляции, но не в рантайме. Например, различные кодогенераторы: lombok, 
- `runtimeOnly` - зависимости, которые нужны только в рантайме
- `testImplementation` - зависимости, которые нужны только в тестах
- Устаревшие
  - `compile` - удалена в Gradle 7.0

Конфигурации могут выстраиваться в иерархии с помощью наследования.
Например, конфигурация `testImplementation` наследуется от `implementation`, поэтому в тестах в classpath будут помещены зависимости и той, и другой конфигурации.

### Создание собственных конфигураций
todo

Объявление конфигурации:
```kotlin
val liquiScripts: Configuration by configurations.creating
```

---
## Таски
Таска - это какая-то работа, например компиляция каких-либо файлов, генерация документации или создание jar.
Про таски можно почитать в [отдельной заметке](gradle_tasks.md).


---
## Plugins
Плагин - это подключаемый модуль, который добавляет различную функциональность для сборки проекта.
Плагины можно разделить на три группы:
- встроенные в Gradle. Если вы установили Gradle, значит они уже есть, осталось только импортировать их в проект.
- внешние плагины, выкачиваемые из различных публичных (и закрытых) репозиториев. Для подключения требуется указать полное имя и версию плагина
- локальные (конвенциональные) плагины, которые написаны в рамках проекта. Не требуют указания версии, потому что лежат в том же репозитории

Разница в объявлении:
```kotlin
plugins {
  java // built-in plugin
  id("io.qameta.allure") version "2.11.2" //Community plugin
  id("my.sweet.plugin") //Local plugin
}
```

По умолчанию плагины подгружаются из репозитория `Gradle Plugin Portal`. 
Но всегда можно добавить собственные репозитории с плагинами с помощью `pluginManagement`.
Чаще всего его прописывают в `settings.gradle`.
```kotlin
pluginManagement {
    repositories {
        maven(url = "./maven-repo")
        gradlePluginPortal()
        maven(url = "nexus.mycompany.com/gradle-plugins")
    }
}
```

Здесь же можно указать версии плагинов, чтобы не нужно было повторять их во всех сабмодулях:
```kotlin
pluginManagement {
  val myPluginVersion: String by settings
  plugins {
    id("my.sweet.plugin") version "${myPluginVersion}"
  }
}
```

Вместе с Gradle поставляются следующие плагины:
- `base` - добавляет основные таски вроде `build`, `clean`
- `java` - добавляет таски для основных операций с java проектами: `classes`, `compileJava`, etc.
- `java-library` - вдобавок к `java` добавляется конфигурация `api`
- `application` - стандартное java приложение. Добавляется таска `run`


### Написание собственных плагинов
Таски - это, конечно, круто! Но когда их становится слишком много в build файле, работа с ним перестает быть комфортной.
Поэтому рекомендуется выносить таски в плагины, и оставлять свой `build.gradle` файл девственно чистым.
todo


---
## Command Line Interface

Любые таски Gradle можно запускать из командной строки.

```shell
gradle clean build -x test
```

Ключ `-q` отключает вывод в командную строку логов, оставляя только то, что выводят в консоль таски.

### Gradle Wrapper
У разных разработчиков, работающих над одним проектом, могут быть установлены разные версии Gradle. 
Из-за этого у разных людей билд может проходить по-разному.
Чтобы у всех все было одинаково решили указывать конкретную версию Gradle сразу в проекте, а вызывать нужную версию с помощью скрипта.
Для этого в директории проекта должны быть файлы:
- `gradlew.bat` или `gradlew.sh` - основной исполняемый файл со скриптами
- `/gradle/wrapper/gradle-wrapper.properties` - основные настройки wrapper'а, здесь же указывается версия Gradle
- `/gradle/wrapper/gradle-wrapper.jar` - исходники gradle wrapper в виде Java-архива

Эти файлы можно выкачать с помощью команды (для этого должен быть установлен Gradle)
```shell
gradle wrapper
```
Эта таска есть по умолчанию в каждом Gradle проекте.
Будет выкачана версия Gradle Wrapper, соответствующая установленному Gradle.

При выкачке можно указать тип дистрибутива: `bin` или `all`. 
`bin` не содержит в себе документации и исходников gradle.
По умолчанию используется `bin`.
```shell
gradle wrapper --distribution-type all
```

Используемая версия Gradle указывается в настройке `distributionUrl` файла `gradle-wrapper.properties`.
Она будет выкачена в директорию `build/` проекта и в `wrapper/dists/` в директории с установленным Gradle.

Теперь из корня проекта можно запускать таски так же, как это делается для CLI, только первым словом будет обращение к файлу со скриптом:
```shell
./gradlew clean build -x test 
```


---
## Инкрементальный билд
Gradle запоминает результаты исполнения промежуточных тасок, что позволяет не запускать некоторые таски при повторных билдах.
> Возможно это работает как-то иначе, нужно разбираться глубже.
> Предполагаю, что Gradle как-то хэширует входные и выходные данные тасок, и если при очередном запуске хэш не поменялся, то скипает таску.

Gradle не может самостоятельно узнать какие данные являются входными и выходными для тасок.
Это необходимо прописывать явно, чтобы инкрементальный билд корректно работал.

### Build cache
Результаты исполнения тасок можно кэшировать, что бывает полезно, если ты часто переключаешься с одной ветки на другую.
Для этого при запуске таски нужно добавить ключ `--build-cache`.

Особенно полезным это может быть при встраивании в CI.
На CI включается кэширование тасок, а когда какой-нибудь разработчик выкачивает ветку, то из CI заодно выкачивает кэш для тасок.
В таком случае проект в выбранной ветке будет билдиться мгновенно.
Но, конечно, нужно иметь ресурсы на содержание кэша, и хороший сетевой канал, чтобы дополнительно выкачивать кэш.

---
## К изучению
- [ ] [Документация](https://docs.gradle.org/current/userguide/getting_started.html) на Gradle
- [ ] Доклад [Евгений Борисов - Power of Gradle](https://www.youtube.com/watch?v=NZJTYPLb0iE&ab_channel=JUG.ru) 2013 г.
- [X] Что такое [Gradle Wrapper](https://medium.com/@bherbst/understanding-the-gradle-wrapper-a62f35662ab7)
- [ ] [Plugins](https://docs.gradle.org/current/userguide/plugins.html)
- [ ] [How to make plugin](https://github.com/jjohannes/gradle-plugins-howto)
- [ ] [Idiomatic gradle](https://github.com/jjohannes/idiomatic-gradle)
- [ ] [Конфигурации зависимостей](https://docs.gradle.org/current/userguide/declaring_dependencies.html)