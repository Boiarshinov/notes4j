---
title: "JPA. Настройка первичного ключа"
tags:
  - java_and_db
  - jpa
draft: false
---

В классе сущности должно быть поле, которое выступает в роли первичного ключа, такое поле помечается аннотацией `@Id`.

Почти всегда значения идентификатора назначаются не вручную, а автоматически. Для этого над полем первичного ключа вешается аннотация `@GeneratedValue`. При этом существуют различные стратегии генерации первичного ключа:

### Стратегии генерации

Над первичным ключом также обычно вешают аннотацию `@GeneratedValue`, которая определяет стратегию автоматической генерации значения.

Необходимость выбора какой-то стратегии генерации вызвана тем, что java-приложения работают в конкурентной среде, и запись в таблицу новых строк может вестись одновременно.

Выбор стратегии определяется путем присваивания переменной `strategy` значения перечисления из перечисления `GenerationType`:

- `TABLE` - присваивает значения первичным ключам по специальной таблице, которую нужно создать самостоятельно и заполнить первоначальными данными. Данный вариант платформонезависим, но уменьшает скорость работы БД.
- `SEQUENCE` - присваивает значения первичному ключу исходя из сиквенса таблицы. Такая стратегия подходит для PostgreSQL и Oracle. При использовании данной стратегии, необходимо в аннотации указать имя сиквенса.

```java
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "person_id_seq")
```

- `IDENTITY` - присваивает значения первичному ключу с помощью автоинкремента, стоящего на колонке таблицы. В MySQL такой идентификатор должен быть создан со свойством `autoincrement`, в PostgreSQL тип идентификатора должен быть `serial`.
- `AUTO` - стратегия будет выбрана автоматически в зависимости от вендора JPA и СУБД.

Наиболее предпочтительным способом является генерация с помощью сиквенса.

При генерации с помощью сиквенса идентификатор будет присвоен сущности при ее переводе из состояния `new` в состояние `managed / persist`. При этом в БД отправляется запрос на чтение, а не на запись, что хорошо сказывается на быстродействии приложения.

В случае со стратегией `IDENTITY` при переводе сущности из состояния `new` в состояние `managed / persist` всегда происходит вставка в таблицу, соответствующей сущности, нового записи. Этот факт не позволяет провести оптимизацию работы с БД на уровне JDBC.

В различных реализациях JPA могут существовать дополнительные стратегии генерации первичного ключа.

Первичный ключ может быть составным, но это требует дополнительной нетривиальной настройки.

---
## К изучению

- [X] Документация на пакет `javax.persistence` в части касающейся
- [X] Разница между типа генерации первичного ключа: https://thorben-janssen.com/jpa-generate-primary-keys/
- [X] Книга "Java Persistence API и Hibernate" в части касающейся