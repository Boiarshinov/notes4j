---
title: "JPA. Связи между сущностями"
tags:
  - java_and_db
  - jpa
draft: false
---

Заметка состоит из связанных между собой частей:

- Типы связей и примеры их применения
- Каскадирование
- Типы выборки

Если в одной части встретились непонятные термины, то возможно они объяснены чуть дальше.

Что такое сущности и как они описываются расписано в заметке [JPA. Описание сущностей](jpa_entity.md).

---
## Один к одному

### Один к одному - однонаправленная связь

Один к одному - достаточно редкий вид связи между таблицами. Между двумя таблицами должен быть определен внешний ключ.

В сущности той таблицы, где имеется внешний ключ, необходимо завести поле класса другой сущности и поставить над полем две аннотации: `@OneToOne` и `@JoinColumn(name = "<foreign_key_attribute>")`.

```java
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "instructor_detail_id")
private InstructorDetail instructorDetail;
```

Чаще всего для связи один к одному используется тип каскадирования `ALL`.

### Один к одному - двунаправленная связь

Для того чтобы обеспечить двунаправленную связь у обеих сущностей должны быть поля друг друга.

Конфигурация поля внешней сущности такая же, как для однонаправленной связи. Для конфигурации поля внутренней сущности нужно поставить над ним аннотацию `@OneToOne`, задав значение атрибута mappedBy, передав ему имя поля внутренней сущности в классе внешней сущности.

```java
@Entity
@Table("additional_info)
public class AdditionalInfo {
    @OneToOne(mappedBy = "additionalInfo", cascade = CascadeType.ALL)
    private PrimaryInfo primaryInfo;
}
```

Для того чтобы удалить одну сущность, не удаляя другую, нужно засеттить им в поля друг друга null.

---
## Один ко многим

### Один ко многим - двунаправленная связь

Один ко многим - очень распространенный вид связи между таблицами. В таблице, представляющей многих, должен быть определен внешний ключ, указывающий на первичный ключ другой таблицы. В сущности таблицы, которая представляет многих, необходимо определить поле, указывающее на сущность другой таблицы (представляющих одного). Над этим полем нужно поставить аннотацию `@ManyToOne`. В эту аннотацию необходимо передать тип каскадирования. Также над полем нужно повесить аннотацию `@JoinColumn`, указав атрибут внешнего ключа.

```java
@ManyToOne(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
@JoinColumn(name = "instructor_id")
private Instructor instructor;
```

В таблице, представляющей одного, нужно создать список / множество сущностей таблицы, представляющей многих.

Эта группа сущностей другой таблицы должна быть выражена одним из стандартных интерфейсов: `Set`, `List`, `Collection`.

Над этим полем надо повесить аннотацию `@OneToMany`. В этой аннотации необходимо указать ссылку на поле в другой сущности, над которым стоит `@ManyToOne`. Делается это с помощью атрибута `mappedBy`.

```java
@OneToMany(mappedBy = "instructor",
    cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
private final List<Course> courses = new ArrayList<>();
```

Экземпляр пустой коллекции лучше создать сразу же, чтобы не напороться где-нибудь на NPE.

Когда требуется создать двунаправленную связь, необходимо сделать оба действия: дать "одному" ссылки на всех "многих"; и дать "многим" ссылку на "одного".

Поэтому стоит определить метод, который позволит добавлять в список новые сущности, при этом создавая необходимые связи:

```java
public void addCourse(Course course) {
    course.setInstructor(this);
    courses.add(course);
}
```

Чтобы сохранить в БД сущности таблицы "многих" со ссылкой на сущность "одного", нужно добавить их в список в объект сущности "одного":

```java
final Course guitarCourse = new Course("Electrical Guitar");
final Course classicGuitarCourse = new Course("Classic Guitar");

instructor.addCourse(guitarCourse);
instructor.addCourse(classicGuitarCourse);

session.save(guitarCourse);
session.save(classicGuitarCourse);
```

Чтобы поддержать целостность данных, всегда стоит давать доступ к коллекции элементов "многих" предварительно обернув его в *немодифицируемую коллекцию*, а сеттер не предоставлять вовсе:

```java
public Collection<Course> getCourses() {
    return Collections.unmodifiableCollection(this.courses);
}
```

### Один ко многим - однонаправленная связь

Однонаправленная связь используется, когда сущность "многих" неразрывно связана с сущностью "одного" и не может восприниматься отдельно от нее. Такой вид связи подходит, например, для связи между собой постов и комментариев под ними. В таком случае сущность "многих" может не иметь явного поля, указывающего на сущность "одного".

Настройка сущностей происходит следующим образом:

- В сущности "одного" связь с таблицей "многих" указывается с помощью аннотации `@JoinColumn` с ссылкой на столбец внешнего ключа в таблице "многих". Тип каскадирования обычно - `ALL`.
- В сущности "многих" не создается ничего, что указывало бы на сущность "одного".

Типичная настройка в сущности "одного":
```java
@OneToMany(cascade = CascadeType.ALL)
@JoinColumn(name = "course_id")
private List<Review> reviews = new ArrayList<>();
```

---
## Многие ко многим

В реляционных БД для представления связи многие ко многим используется дополнительная таблица.

В JPA для этой промежуточной таблицы не требуется создавать отдельных сущностей. Вместо этого в каждой сущности над полем, представляющими список объектов связанной сущности, ставится аннотация `@ManyToMany`. Таблица, с помощью которой осуществляется связь между сущностями, указывается в аннотации `@JoinTable`. Там же указываются атрибуты внешних ключей.

В одной сущности настройка будет выглядеть так:
```java
@ManyToMany(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
@JoinTable(
    name = "course_student",
    joinColumns = @JoinColumn(name = "student_id"),
    inverseJoinColumns = @JoinColumn(name = "course_id"))
private List<Course> courses = new ArrayList<>();
```

Во второй подобным же образом:

```java
@ManyToMany(cascade = {CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH})
@JoinTable(
    name = "course_student",
    joinColumns = @JoinColumn(name = "course_id"),
    inverseJoinColumns = @JoinColumn(name = "student_id"))
private List<Student> students = new ArrayList<>();
```

Для того чтобы связи между сущностями сохранились в БД, необходимо просто в рамках сессии добавить в коллекцию одной из сущностей объекты другой сущности. Остальное произойдет автоматически.

---
## Каскадирование

Во все аннотации, связывающие между собой сущности, могут быть переданы виды операций над сущностями, которые приведут к каскадному изменению зависимой сущности:

- `PERSIST` -
- `MERGE` -
- `REMOVE` - при удалении
- `REFRESH` -  при обновлении
- `DETACH` -
- `ALL` - все вышеперечисленные

По умолчанию не каскадируется ничего.
```java
@OneToOne(cascade = {CascadeType.DETACH, CascadeType.REMOVE})
```

Как данные типы каскадирования связаны с каскадированием, настраиваемым при создании внешнего ключа?

---
## Типы выборки

При загрузке из БД сложных сущностей, включающих в себя большое количество связей, важно быстродействие. Иногда требуется выгрузить только данные из одной таблицы, а иногда нужно, чтобы ORM получила данные сразу из нескольких таблиц. Для того чтобы настроить тип выгрузки, используется атрибут `fetch` в аннотациях видов связей. Этому атрибуту присваивается одно из значений перечисления FetchType:

- `EAGER` - жадный. При запросе одной сущности, из БД будут вытащены все связанные с ней сущности.
- `LAZY` - ленивый. При запросе одной сущности, другие сущности вытащены не будут. Но они будут вытащены при обращении к их полям в той же сессии.

Для каждого вида связи есть значение типа выборки по умолчанию:

| **Вид связи** | **Значение по умолчанию** |
| --- | --- |
| `OneToOne` | Жадный |
| `OneToMany` | Ленивый |
| `ManyToOne` | Жадный |
| `ManyToMany` | Ленивый |

---
## К изучению

- [ ] Документация на пакет javax.persistence
- [X] Курс по Spring и Hibernate на Udemy (в части касающейся): https://www.udemy.com/course/spring-hibernate-tutorial
- [X] JPA и связи между объектами: https://easyjava.ru/data/jpa/jpa-i-svyazi-mezhdu-obektami/
- [ ] Книга "Java Persistence API и Hibernate"