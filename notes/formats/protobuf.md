---
title: "Protobuf"
tags:
  - formats
  - binary
draft: true
---

# Protobuf

**Protobuf** - бинарный [формат](./formats.md) представления данных, разработанный Google.
Protobuf используется как основной формат сериализации в протоколе gRPC, но может быть применен и отдельно от него.

Для описания структуры сообщения используется свой собственный язык.
Описание сообщений принято хранить в отдельных файлах с расширением `.proto`.

На основе данных файлов компилятор __protoc__ может сгенерировать код для множества языков программирования: Java, C++, C#, Python, Go и многих других.
Существуют и другие компиляторы для различных языков. Например:
- Java: Wire
- Kotlin: kotlinx.serialization
- [Другие](https://github.com/protocolbuffers/protobuf/blob/main/docs/third_party.md)

На данный момент (2023 г.) поддерживается две версии формата:
- proto2
- proto3

Создатели Protobuf уже не работают в Google и в рамках отдельного проекта выпустили дальнейшее развитие Protobuf - [Cap'n Proto](https://capnproto.org/).

### Совместимость
Важнейшей задачей при разработке формата была поддержка прямой и обратной совместимости при развитии модели сообщения.
Если мы попытаемся распарсить сообщение, которое было создано по старой структуре, с помощью новой структуры, то при десереализации геттеры новых полей будут отдавать дефолтные значения.
Если мы попытаемся распарсить сообщение с помощью устаревшей структуры, то все новые поля будут просто проигнорированы.

---
## Структура сообщения
```proto
syntax = "proto3";

/* Длинный комментарий, который превратится в javadoc на класс.
 * Все начинается с ключевого слова `message` */
message MyMessage {
  string name = 1; //Комментарий превратится в javadoc к полю
  int32 age = 2;
}
```

Каждому полю надо присвоить уникальный номер, который является якорем для сериализатора/десериализатора.
При изменении сообщения: удалении полей или добавления новых, очень важно не переиспользовать ранее использованные номера, т.к. это может нарушить совместимость.
Для этого можно использовать ключевое слово `reserved`.
```proto
reserved 2; //Поле удалено за ненадобностью
```

---
## Типы

- Скалярные типы
  - `int32`
  - `uint32` - unsigned int - подходит только для положительных целых чисел
  - `sint32` - signed int - отличается от int32 тем, что лучше энкодирует отрицательные числа
  - `int64`
  - `uint64`
  - `sint64`
  - `float`
  - `double`
  - `bool`
  - `string` - строка в формате UTF-8
  - `bytes`
- перечисления
- сообщения
- `map`

Поле любого типа может быть объявлено с ключевым словом `repeated`, что означает, что это поле является массивом значений заданного типа.

### Перечисления

Перечисления объявляются с помощью ключевого слова `enum`:
```proto
message MyMessage {

  Status status = 4;

  enum Status {
    UNKNOWN = 0;
    ACCEPTED = 1;
    DENIED = 2;
    IN_PROGRESS = 3;
  }
}
```
Значения перечисления должны обязательно начинаться с нуля.

При сериализации перечисления представляются в виде 32-битного целого числа (`int`).

Если поле перечисляемого типа не было заполнено при сериализации, то при десериализации в него будет записано первое объявленное значение.
Поэтому рекомендуется во всех своих перечислениях первым элементом объявлять значение с именем `UNKNOWN` или `UNSPECIFIED`.

При удалении каких-либо значений из перечисления, чтобы избежать различных ошибок при дальнейшем развитии модели, следует заблокировать имя или номер удаленного перечисления:
```proto
enum Status {
  reserved 2;

  UNKNOWN = 0;
  ACCEPTED = 1;
  IN_PROGRESS = 3;
}
```

### Дефолтные значения
Protobuf не поддерживает `null`.
Если при сериализации не были заданы значения у переменных, то при десериализации они получат дефолтные значения:
- `string` - пустая строка `""`
- `int32`, `double` и другие числовые типы - `0`
- `boolean` - `false`
- `enum` - перечисление с индексом `0`
- `repeated` - пустой массив `[]`
- `map` - пустая мапа `{}`

С полями типа `message` отдельная история. 
В Java если при сериализации такое поле не заполнить, то внутри Java объекта будет лежать null, но если попробовать извлечь поле с помощью геттера, то вернется объект с дефолтными полями.
Но protobuf генерирует для полей типа `message` методы `has<FieldName>`, которые позволяют узнать, было ли задано поле при создании объекта.


### Опциональные поля
todo


---
## JSON-представление
Стандартный инструментарий protobuf позволяет представлять proto-сообщение в виде JSON.
И наоборот десериализовать JSON в proto-сообщение.
Это может быть полезно для преобразования proto-сообщения в человекочитаемый вид.
Например, такое преобразование используется в приложениях тестирования, например, в Postman или BloomRPC.
В одном из проектов мы использовали такое преобразование, чтобы сопровожденцы могли просмотреть данные, хранившиеся в базе данных Hazelcast в виде proto-сообщений.


---
## Важные нововведения

- 3.0 (2016 г.) - вышла версия proto3
- 3.5 (2017 г.) - unknown fields
- 3.7 (2019 г.) - для Java появился BOM
- 3.15 (2021 г.) - в proto3 вернули ключевое слово `optional`. Для полей с такой пометкой генерируются методы `hasField()`. Также `hasField()` генерируется для `oneOf` полей
- 3.17 (2021 г.) - в protoc появилась возможность вдобавок к Java-коду генерировать DSL для Kotlin
- 4.26 (2024 г.) - удалены многие методы, которые ранее были помечены устаревшими. Введена новая система фич описания формата сообщений: protobuf editions


---
## К изучению
- [ ] [Документация](https://developers.google.com/protocol-buffers/docs/proto3)
- [X] [Release notes](https://github.com/protocolbuffers/protobuf/releases)
