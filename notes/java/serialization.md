---
title: "Сериализация"
tags:
  - core
draft: false
---

Сериализация - это процесс преобразования объектов в поток байтов, который позволяет потом расшифровать этот поток и восстановить объект. Обратный процесс называется десериализацией - восстановление сериализованного объекта из потока.

---
## Интерфейс `Serializible`

Для того чтобы объект можно было сериализовать его необходимо пометить интерфейсом-маркером `Serializible`.
```java
class MyClass implements Serializible { ... }
```

Все поля объекта, которые должны быть сохранены, тоже должны быть сериализуемыми.

Объекты примитивных типов и их оберток, строки, контейнеры являются сериализуемыми.

В javadoc для сериализуемых полей делается отметка `@serial`, это не обязательно, но считается хорошим тоном.

Автоматически не сериализуются:

- Статические поля
- Поля, помеченные `transient`
- Унаследованные от суперкласса поля (при десериализации будут инициализированны автоматически с помощью конструктора суперкласса без параметров)

Если очень хочется сериализовать статические переменные, то можно, см. раздел ниже.

Если вы не хотите, чтобы поле сериализовывалось, необходимо пометить его ключевым словом `transient`.

---
## Как сериализовать?

Для сериализации используется класс `ObjectOutputStream`

Конструкторы:
- `ObjectOutputStream(OutputStream)`

Методы:
- `void writeObject()` - записывает объект в поток
- `void defaultWriteObject()` - то же, что и предыдущий, но на случай если обычный метод переопределен в сериализуемом классе. Обычно используется при сериализации статических полей.

---
## Как десериализовать?

Для десериализации используется класс `ObjectInputStream`

Конструкторы:
- `ObjectInputStream(InputStream)`

Методы:
- `Object readObject()` - читает из потока объект и возвращает его
- `Object defaultReadObject()` - то же, что и предыдущий, но на случай если обычный метод переопределен в сериализуемом классе. Обычно используется при сериализации статических полей.

При десериализации конструктор объекта не вызывается, а это значит, что всем статическим переменным и переменным, помеченным ключевым словом `transient`, будет присвоено нулевое значение 0 / null (в зависимости от типа).

---
## Сериализация Singleton

Для того чтобы сериализовать Singleton необходимо добавить в него метод `readResolve()`:
```java
private Object readResolve() throws ObjectStreamException { return INSTANCE; }
```

При десериализации будет вызван данный метод, который вернет ссылку на нужный инстанс синглтона.

Даже несмотря на наличие этого метода ObjectInputStream все равно прочитает объект и только потом будет произведена проверка на наличие метода `readResolve()`. Десериализованный объект отправится к сборщику мусора.

Для того чтобы обезопаситься от атак недоброжелателей, необходимо все поля синглтона помечать `transient`. Либо можно вместо класса использовать перечисление с единственным значением.

---
## Сериализация статических полей

Если очень хочется сериализовать статическое поле, то нужно ухищряться, переопределяя методы `writeObject()` и `readObject()`. Каждое статическое поле необходимо принудительно записать в поток / считать из потока с помощью `writeObject()` / `readObject()`. Пример:

```java
public class MyClass implements Serializible {
    public static String staticString = "abcd";

    private void writeObject(ObjectOutputStream outStream) throws IOException {
        outStream.defaultWriteObject();
        outStream.writeObject(staticString);
    }

    private void readObject(ObjectInputStream inStream) throws IOException, ClassNotFoundException {
        inStream.defaultReadObject();
        staticString = (String) inStream.readObject();
    }
}
```

При попытке сериализации или десериализации автоматически будет осуществлена проверка на наличие в классе переопределенных методов, и если они есть, то будут вызваны они.

---
## Запрет сериализации

Если ваш класс унаследован от класса, который реализует интерфейс `Serializible`, то ваш класс по умолчанию тоже будет реализовывать его. Но что если вы не хотите, чтобы ваш класс можно было сериализовать?

Для этого необходимо переопределить методы `writeObject()` и `readObject()` и выкинуть в них исключения `NotSerializibleException`:

```java
private void writeObject(ObjectOutputStream out) throws IOException {
    throw new NotSerializableException("Не сегодня!");
}
private void readObject(ObjectInputStream in) throws IOException {
    throw new NotSerializableException("Не сегодня!");
}
```

---
## Идентификатор SerialVersionUID

Для того чтобы при десериализации можно было понять в какой именно класс нужно десериализовать объект, при записи в поток для объекта генерируется уникальный идентификатор, который называется serialVersionUID. Он генерируется на основе полей, порядка их объявления и методов класса.

Проблема с этим идентификатором заключается в том, что при малейшем изменении класса, даже при перестановке полей местами, или изменении названия класса, идентификатор изменяется. И поэтому при внесении малейших изменений в сериализуемый класс ломается вся обратная совместимость: становится невозможно десериализовать объекты, сериализованные до изменения класса.

Для того чтобы избежать потери обратной совместимости в класс иногда вводят константу `serialVersionUID`:
```java
private static final long serialVersionUID = ...
```

Значение serialVersionUID можно выбрать одним из следующих способов:

- самому придумать рандомное значение типа `long`;
- воспользоваться утилитой `serialver`;
- при реализации интерфейса `Serializible` Intellij IDEA самостоятельно предлагает создать уникальный идентификатор.

Объявление собственного значения `serialVersionUID` также уменьшит время сериализации объектов, т.к. не будет тратиться время на вычисление его значения.

---
## Интерфейс `Externalizible`

Необходимость создания такого интерфейса вызвана недостатками интерфейса `Serializible`:
- Низкая скорость работы
- Малый инструментарий
- Отсутствие шифрования данных

Если вас не устраивает стандартная сериализация, то ее можно прописать самому, а для того, чтобы пометить класс как сериализируемый, вручную ему имплементируется интерфейс `Externalizible`.

В классе, реализующем такой интерфейс, должны быть реализованы следующие методы:
- `void writeExternal(ObjectOutput)`
- `void readExternal(ObjectInput)`

В классе, реализующем интерфейс `Externalizible`, *обязательно должен быть пустой конструктор*. Он запускается в неявном виде в начале метода `readExternal()`.

Десериализировать поля, помеченные модификатором `final`, невозможно, потому что они будут проинициализированы нулями при вызове конструктора.

Внутри можно пользоваться всеми методами классов `ObjectInput` и `ObjectOutput`, при этом рекомендуется при записи примитивных типов использовать специальные методы.

Методы `ObjectInput`:
- `void writeObject(Object)`
- `void writeInt(int)`
- и так для всех примитивов

Методы `ObjectOutput`:

- `Object readObject()`
- `int readInt()`
- и так для всех примитивов

### **Нюансы:**

1. Объект, который уже был однажды сериализован в поток, записывается в кэш и при повторной сериализации записывается из кэша, хотя за это время он мог быть изменен. Для того чтобы предотвратить запись ошибочных данных необходимо либо очистить кэш перед записью с помощью `ObjectOutputStream.reset()`, либо закрыть поток и открыть снова.
2. Автоматическая сериализация работает медленнее, чем созданные пользователем выводы в потоки.
3. При десериализации объекта дочернего класса в неявном виде вызывается конструктор без параметров родительского класса. Если такого конструктора нет, то вылетит ошибка. Вывод: если родительский класс не сериализуемый, то его поля нужно сериализовывать и десериализовывать вручную.
4. Если внутри класса объявлен еще один класс (внутренний) с сериализацией, то необходимо, чтобы внешний класс тоже имплементировал `Serializible`

---
## К изучению:

- [X] http://javadata.blogspot.com/2011/12/singleton-and-serialization.html
- [X] http://ccfit.nsu.ru/~deviv/courses/oop/java_ser_rus.html
- [ ] http://www.skipy.ru/technics/serialization.html#performance
- [ ] https://habr.com/ru/post/319604/
- [ ] https://java2blog.com/serialversionuid-in-java-serialization/
- [X] Генерация serialVersionUID в IDEA:  https://stackoverflow.com/questions/12912287/intellij-idea-generating-serialversionuid
- [X] Глава книги "Джошуа Блох. Java. Эффективное программирование", посвященная сериализации (прочитал, но не все законспектировал)