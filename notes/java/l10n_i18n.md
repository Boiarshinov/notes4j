---
title: "Локализация / Интернационализация"
tags:
  - text
draft: false
---

**Интернационализация** (i18n) - это процесс разработки приложения такой структуры, при которой дополнение нового языка не требует перестройки и перекомпиляции (сборки) всего приложения. Достигается это за счет отдельного хранения данных интернационализации в виде файлов свойств, загружаемых приложением динамически в процессе работы.

**Локализация** (l10n) – это адаптация приложения к конкретному языку и региону путем перевода выводимых пользователю текстовых элементов и документации, а также определения данных времени, валют и др., согласно специфике данного региона.

---
## Класс Locale
Класс Locale используется для представления различных языков, стран и регионов.

- язык - обозначается на английском от 2 до 8 прописных букв. Пример: "ru"
- страна (регион) - обозначается либо двумя строчными буквами, либо трехзначным кодом. Примеры: "FR", "029"
- шрифт (алфавит?) - обозначается 4-х буквенным сокращением. Пример: "Cyrl" для кириллицы
- вариант - вариант локали для тех стран, где может отличаться семантика в различных областях страны.
- дополнения - ??

Создание локали:
- Можно создать с помощью шаблона builder
```java
Locale locale = new Locale.Builder().setLanguage("ru").setRegion("RU").build();
```
- Можно воспользоваться одним из конструкторов:
    - `Locale(String language)` - создает локаль на основе одного только языка
    - `Locale(String language, String country)` - создает локаль на основе языка и страны
    - `Locale(String language, String country, String variant)` - создает локаль на основе языка, страны и варианта, характерного для определенной области страны (ну это что-то прям совсем редкое)
- Можно воспользоваться дефолтной локалью:
```java
Locale.getDefault();
```
- Использование стандартной локали (русской среди них нет):
```java
Locale locale = Locale.GERMANY; //аналог new Locale("de", "DE")
```
- С помощью одного красивого тега:
```java
Locale locale = Locale.forLanguageTag("de-POSIX-x-URP-lvariant-Abc-Def"); //что бы это ни значило
```
### Поиск подходящей локали
Для поиска подходящей локали используется два механизма:
- filtering - находит все подходящие локали
- lookup - выбирает самую подходящую локаль

---

## Класс ResourceBundle
Класс ResourceBundle является абстрактным и имеет несколько реализаций:

- `PropertyResourceBundle` - читает из properties-файлов.
- `ListResourceBundle` - читает из java-файлов.

ListResourceBundle позволяет поставлять не только локализованные строки, но и объекты. Зато PropertyResourceBundle не требует перекомпиляции при изменении локализованных сообщений, достаточно просто заменить файл.

Чтение из ресурса происходит следующим образом: необходимо создать экземпляр класса для выбранного ресурса и локали с помощью метода getBundle():
```java
ResourceBundle resourceBundle = ResourceBundle.getBundle("text", locale); //Бандл будет читать из файла text.properties или text.java с наиболее подходящей локализацией.
```

Тип ресурса будет выбран автоматически по переданному имени.

Чтение нужного параметра из ресурса производится с помощью метода `getString()` для properties-файлов и `getObject()` для java-классов:
```java
String message = resourceBundle.getString("messageKey");
```

### PropertyResourceBundle

Класс предназначен для чтения локализованных данных из [properties-файлов](properties.md).

Файлы с локализованными данными должны быть именованы следующим образом:
```
<имя файла>_<язык>_<регион>.properties
```

Также обязательно должен быть файл без указания языка и региона, который будет использоваться при отсутствии подходящего файла локализации (и без него ResourseBundle будет бросать исключения).

### ListResourceBundle

Класс предназначен для чтения локализованных данных из Java-классов.
Для каждой локали должен быть определен свой класс.
Классы с локализованными данными должны быть именованы следующим образом:
```java
public class <ResourceName>_<language>_<REGION> extends ListResourceBundle { /* ... */ }

Внутри класса должен быть реализован метод getContents():
@Override
protected Object[][] getContents() {
    return new Object[][] {
    {"currency", "polish zloty"},
    {"toUsdRate", new BigDecimal("3.401")},
    {"cities", new String[] { "Warsaw", "Cracow" }}
    };
}
```

---

## Наследование

При чтении из ресурса с указанной локалью создается список подходящих ресурсов. Например, для ресурса resource_ru_RU в приложении, поднятом в Англии будут создан следующий список с подходящими именами ресурсов:
```
resource_ru_RU
resource_ru
resource_en_UK
resource_en
resource
```
Теперь при попытке вызова из нашего ресурса данных по ключу
`resourceBundle.getString("messageKey");`

будет осуществлен поиск переданного ключа последовательно в каждом из возможных ресурсов до нахождения первого совпадения.

Таким образом дочерние ресурсы наследуют все локализованные данные родительских ресурсов и могут их переопределять.

---

## Кодировки
При чтении локализованных данных из properties-файлов строки считываются в кодировке ISO_8859_1, в которой определены не все символы. Поэтому необходимо обязательно конвертировать строки в UTF-8.
```java
private static String getString(final String key) {
    final String message = resourceBundle.getString(key);

    return new String(message.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);

}
```

В Java 9 эта проблема была решена и теперь properties-файлы читаются сразу в кодировку UTF-8.

---
## Реализация интернационализации веб-приложений
Самый интересный вопрос на который хотелось бы найти ответ.

---
## К изучению:
- [ ] Javadoc на Locale
- [X] Цикл кратких статей по интернационализации: https://www.examclouds.com/ru/java/java-core-russian/internationalisation
- [X] Шикарная статья на Baeldung про ResourceBundle: https://www.baeldung.com/java-resourcebundle