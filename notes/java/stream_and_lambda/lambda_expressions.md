title: "Лямбда-выражения"
tags:
  - java_8
  - functional_programming
draft: false
---

Лямбда-выражения - это анонимные функции.

Чаще всего лямбда-выражения используются для выполнения последовательности действий, которая будет выполняться всего 1 раз. Таким образом исчезает необходимость написания отдельного класса.

## Синтаксис лямбда-выражений

При написании лямбда-выражений используется следующий синтаксис: `(аргументы) -> { перечень выражений; return значение}`
```java
(x, y) -> {
    StringBuilder s = new StringBuilder();
    for (int i = 0; i < x; i++) s.append("лол");
    for (int i = 0; i < y; i++) s.append("кек");
    return s.toString();
}
```

Существует и укороченная форма записи, в которой нет оператора return. Так можно писать если, в лямбде только одно выражение
```java
() -> System.out.println("Hello World!");
```
Также return можно не писать, если <mark>//??</mark>

Тип параметров, передающихся лямбда-выражению, можно задавать самостоятельно, или он может быть получен автоматически из контекста.

Если параметр один и его тип не указан, то скобки можно не писать:
```java
n -> (n % 2) == 0;
```

## Ссылки на методы
Существуют способы конвертации обычных методов в лямбда-выражение. Для этого используется оператор двойное двоеточие `::`. Синтаксис в данном случае следующий:
- для обычных методов - `имя_переменной_с_объектом::метод_без_скобок`
- для статических методов - `имя_класса::метод_без_скобок`
- для обычных методов, объявленных в другом классе - `имя_класса::метод_без_скобок`
```java
List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
list.forEach(System.out::println)
```
### Ссылка на конструктор
```java
IntFunction<String[]> arrayAllocator = String[]::new;
```

## Какие переменные можно использовать в лямбда-выражениях
- Переменные, переданные лямбда-выражению в качестве аргументов (очевидно)
- Поля класса, в котором вызывается лямбда. Их можно и читать и писать
- Переменные, объявленные в методе, в котором используется лямбда. Можно только читать. Эти переменные не могут быть переопределены и после вызова лямбды (т.е. они финальные, даже если не стоит модификатора final)

Для того чтобы обойти последнее ограничение можно использовать трюк с объявлением массива единичной длины, в который закладывать значение, требующее возможности изменения в лямбде или после нее
```java
int[] counter = new int[] {0};
IntSupplier sequence = () -> counter[0]++; //Обошли ограничение
```

---
## К изучению:
- [X] Плохая статья https://javarush.ru/groups/posts/845-lambda-vihrazhenija-na-primerakh
- [X] Отличная статья https://javarush.ru/groups/posts/264-populjarno-o-ljambda-vihrazhenijakh-v-java-s-primerami-i-zadachami-chastjh-1-
- [X] Вторая часть предыдущей https://javarush.ru/groups/posts/283-populjarno-o-ljambda-vihrazhenijakh-v-java-s-primerami-i-zadachami-chastjh-2-
- [X] Курс на Stepik по функциональному программированию (на англ.): https://stepik.org/course/1595/syllabus
- [X] Р. Уорбэртон - Лямбда-выражения в Java 8
- [ ] Создают ли лямбды лишние объекты: https://stackoverflow.com/questions/27524445/does-a-lambda-expression-create-an-object-on-the-heap-every-time-its-executed/27524543#27524543