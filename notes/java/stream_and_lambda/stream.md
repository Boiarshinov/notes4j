---
title: "Стримы - Stream"
tags:
  - functional_programming
draft: false
---

Стрим - последовательность элементов(может быть даже бесконечной), которая предоставляет возможность выполнять над ней преобразования с помощью простых методов.

Стрим не хранит свои элементы, после того как с ним поработали, он больше непригоден к использованию.

Стрим не позволяет обращаться к определенному элементу.

### Типы стримов:
- `interface Stream<T>` - основной вид стрима
- Стримы примитивов:
    - `class IntStream`
    - `class LongStream`
    - `class DoubleStream`

---
## Жизненный цикл стрима
1. Создание стрима
2. Преобразования стрима (может быть сколько угодно)
3. Терминальная операция, возвращающая полезный результат, после выполнения которой стрим умирает.
4. (Опционально) Закрытие стрима с помощью метода close(). Нужно выполнять, если в стриме открывались ресурсы. Стрим можно определять в блоке try с ресурсами, т.к. он реализует интерфейс `AutoClosable`

Преобразования стрима не начинают выполняться, пока не будет прочитана терминальная операция.

---
## Способы создания стримов
- Вызов метода `iterate(T first, UnaryOperator<U>)` - создает бесконечный стрим с помощью задания первого элемента и функции, которая генерирует последующие элементы
- из любой коллекции с помощью метода `stream()` - создает стрим из элементов коллекции
- из массива с помощью метода `stream(T[])`, определенного в классе `Arrays`
- из `BufferedReader` с помощью метода `lines()` - создает стрим строк
- из директории на диске с помощью методов `list(Path)` и `walk(Path)` класса `Files` - создает стрим путей из всего, что есть в директории (в случае `list()` - только того, что непосредственно в директории, в случае `walk()` - всего что есть в директории и ее поддиректориях и т.д.)
- из строки с помощью метода `IntStream chars()`
- генерация с помощью метода `generate(Supplier<T>)`
- с помощью методов `IntStream.range(int start, int finishExclusive)` или `IntStream.rangeClosed(int start, int finishInclusive)`
- конкатенация двух других стримов `concat(Stream<T>, Stream<T>)`
- перечислить все элементы стрима явно с помощью метода `Stream.of(a, b, c, d)`

---
## Методы преобразования стримов
- `filter(Predicate<T>)` - оставляет только элементы, удовлетворяющие условию
- `limit(int count)` - отсекает указанное количество элементов стрима
- `map(UnaryOperator<U>)` - выполняет указанные преобразования над элементами стрима
- `mapToObj(Function<>)` - //вынести в отдельную заметку про примитивные стримы
- `flatMap(Function<T, Stream>)` - получает с помощью функции набор стримов и конкатенирует их всех в один стрим
- `distinct()` - убирает из стрима дубликаты
- `sorted()` - сортирует по возрастанию (используется, если стрим примитивных типов)
- `sorted(Comparator<T>)` - сортирует стрим по возрастанию с использованием компаратора
- `skip(int)` - выкидывает указанное количество первых элементов из стрима
- `peek(Consumer<T>)` - можно подсмотреть элементы стрима (используется для отладки)

```java
myStream
    .filter(n -> n > 100)
    .distinct()
    .sorted()
    .peek(System.out::println)
    .skip(3)
    .limit(2);
```

---
## Терминальные операции

- `int/long/double sum()` - возвращает сумму элементов стрима (работает только для стримов-примитивов)
- `void forEach(Comsumer<T>)` - выполняет указанное действие для каждого элемента стрима. Данный метод имеет сайд-эффект: он может изменять значения элементов стрима (вместо того, чтобы создавать новые). Поступать таким образом не рекомендуется, если хочется что-то поменять в элементах стрима, то лучше это сделать в методе map(), который создаст новые объекты на основе старых.
- `Optional<T>findFirst()` - возвращает первый элемент из стрима, обернутый в Optional
- `Optional<T>findAny()` - возвращает рандомный элемент из стрима, обернутый в Optional
- Операции матчинга:
    - `boolean allMatch(Predicate<T>)` - проверяет, что все элементы удовлетворяют условию
    - `boolean anyMatch(Predicate<T>)` - проверяет, что хотя бы один элемент удовлетворяет условию
    - `boolean noneMatch(Predicate<T>)` - проверяет, что ни один элемент не удовлетворяет условию
- Редукция и ее частные случаи:
    - `T reduce(T, BinaryOperator<T, T>)` - вычисляет результат свертки стрима (применения унарных операций последовательно к каждому элементу). Первый элемент представляет собой начальное значения аккумулятора, в бинарном операторе первый аргумент - это аккумулятор, который будет возвращен после свертки стрима, а второй аргумент - текущий элемент стрима. Если стрим был пустой, то возвращается значение, указанное в первом параметре

```java
int sum = numbers.stream().reduce(0, (acc, elem) -> acc + elem); //складывает все элементы стрима
```
-
    - `Optional<T> reduce(BinaryOperator<T, T>)` - аналогично методу с начальным значением в качестве одного из аргументов, но возвращает Optional для того чтобы уберечься от пустых стримов.
    - `OptionalDouble min()` - возвращает минимальное значение в стриме примитивного типа (Optional соответствует типу стрима)
    - `Optional<T> min(Comparator<T>)` - возвращает минимальное значение в стриме непримитивного типа
    - `OptionalDouble max()` - возвращает максимальное значение в стриме примитивного типа (Optional соответствует типу стрима)
    - `Optional<T> max(Comparator<T>)` - возвращает максимальное значение в стриме непримитивного типа
    - `long count()` - возвращает количество оставшихся элементов в стриме
- `Collection<T> collect(Collector)` - формирует из стрима коллекцию того типа, который передан с помощью коллектора (см. в классе `Collectors`)
```java
List<String> list = stream1.collect(Collectors.toList());
```

- `R collect(Supplier<R>, BiConsumer<R, T> acc, BiConsumer<R, R> combiner)` -

---
## Параллельные стримы

Параллельные стримы позволяют обрабатывать элементы стримов одновременно в нескольких нитях. Внутри стримовых библиотек параллельность реализована с помощью `ForkJoinPool`.

Стрим можно сделать параллельным несколькими способами:
- вызвать на коллекции метод `parallelStream()`
- преобразовать обычный последовательный стрим в параллельный с помощью метода `parallel()`

Чтобы преобразовать параллельный стрим в последовательный, используется метод `sequental()`.

Важно отметить, что стрим не может быть в каких-то операциях параллельным, а в каких-то последовательным. Стрим будет таким, какой
```java
collection.parallelStream()
    .map(...)
    .sequental()
    .filter(...)
    .parallel()
    .limit(10)
    .sequental()      //В итоге этот стрим последовательный
    .forEach(...)
```

Факторы, влияющие на быстродействие параллельных стримов:
- Объем обрабатываемых данных (количество элементов в стриме)
- Боксинг / анбоксинг.
- Количество ядер
- Длительность обработки одного элемента
- Структура данных элементов стрима

Особенности выполнения параллельных стримов:
- Метод `reduce()` выполняется отдельно для нескольких групп элементов, поэтому начальное значение аккумулятора должно быть нейтральным (например, 0 при суммировании чисел или 1 при умножении чисел).
- Если мы хотим использовать терминальную операцию `forEach()`, то порядок обработки элементов будет произвольным. Для того чтобы обработать элементы упорядоченно, нужно использовать метод `forEachOrdered()`

---
## Отладка стримов

Для отладки стримов имеется грязный хак: нужно внутрь стрима в интересующее место вписать метод `peek()` и поставить на нем точку останова при дебаге.

---
## К изучению:
- [ ] Полное руководство по стримам с анимированными операциями: https://annimon.com/article/2778
- [ ] https://habr.com/ru/company/luxoft/blog/270383/
- [ ] https://habr.com/ru/post/262139/
- [ ] Про библиотеку StreamEx: https://habr.com/ru/post/255659/
- [ ] Примеры стримов на англ.:  https://howtodoinjava.com/java8/java-streams-by-examples/
- [X] Курс на Stepik по функциональному программированию (на англ.): https://stepik.org/course/1595/syllabus
- [X] Р. Уорбэртон - Лямбда-выражения в Java 8
- [ ] Когда использовать параллельные стримы (статья от Дага Ли): http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html
- [X] Восхитительная статья про типичные ошибки при написании стримов: https://habr.com/ru/post/337350/

### Видео
- [ ] Сергей Куксенко - Stream API: https://www.youtube.com/watch?v=O8oN4KSZEXE
- [X] Тагир Валеев - Stream API (примеры решения нетривиальных задач): https://www.youtube.com/watch?v=vxikpWnnnCU
- [ ] Тагир Валеев - Странности Stream API: https://www.youtube.com/watch?v=TPHMyVyktsw