---
title: "Optional"
tags:
  - java_8
  - functional_programming
draft: false
---

**Класс `Optional<T>`** относится к [обобщенным](generics.md).

Класс Optional является примером реализации *монад* в Java.

Конструкторы:
- их нет (то есть они приватные)
- объекты создаются с помощью методов (*unit* в контексте функциональных ЯП):
    - `static Optional<T> empty()` - возвращает обернутый null.
    - `static Optional<T> of(T)` - возвращает ссылку на объект, при этом аргумент не может быть null, иначе будет выкинуто исключение
    - `static Optional<T> ofNullable(T)` - работает как `of()`, но если внутри null, то вернет как `empty()`

Методы:
- Развертывание (получение данных из Optional):
    - `T get()` - возвращает обернутое значение. Если внутри null, то будет выкинуто исключение `NoSuchElementException`.
    - `T orElse(T)` - заменяет тернарный оператор: если значение по вызывающей ссылке не равно null, то возвращается это значение, а если равно null, то возвращается объект, указанный в скобках
    - `T orElseGet(Supplier<T>)` - если значение по вызывающей ссылке не равно null, то возвращается это значение, а если равно null, то возвращается объект, полученный с помощью аргумента-поставщика.
    - `T orElseThrow(Supplier<X>)` - возвращает значение. Если ссылка указывает на null, то бросает исключение, полученное с помощью аргумента-поставщика.
- `boolean isPresent()` - сообщает есть ли значение внутри Optional - true, или там пустая ссылка (null) - false
- `void ifPresent(Consumer<T>)` - Если внутри не null, то выполняет действие, указанное в скобках
- Стримовые методы:
    - `Optional<T> filter(Predicate<T>)` - проверяет, удовлетворяет ли значение внутри Optional заданному условию, если нет, то возвращает пустой Optional.
    - `Optional<U> map(Function<T, U>)` - если обернутый объект существует, то применяет к нему переданную функцию и возвращает значение, обернутое в Optional, иначе возвращает пустой Optional нужного типа.
    - `Optional<U> flatMap(Function<T, Optional<U>>)` - похож на предыдущий метод, но используется в случаях, если переданная функцию сама по себе возвращает значение Optional, что позволяет избавиться от двойного обертывания. В контексте функциональных ЯП этот метод называется *bind*.

Методы, появившиеся в Java 9:
- `Stream<Optional<T>> stream()` - возвращает стрим из этого Optional. Метод позволяет легче оперировать Optional'ами в стримах.
- `void ifPresentOrElse(Consumer<T>, Runnable)` - если элемент существует, то передает его в потребителя, а если отсутствует, то выполняет действие, переданное вторым аргументом.
- `Optional<T> or(Supplier<Optional<T>>)` - Если объект существует, то Optional остается без изменений, а если нет, то он поставляется суплаером. Метод позволяет строить цепочки обработки:

```java
Optional<String> result = wordFromRepo
    .or(() -> this.component1.getWord(id))
    .or(() -> this.component2.getWord(id))
    .or(() -> this.getDefaultWord());
```

---

**Применение**

Класс используется, для того чтобы предупредить пользователей API, что метод может возвращать null вместо объектов. Тем самым пользователи вынуждены будут проверить пришедшее значение на null прежде чем использовать его.

До появления Optional экспертами рекомендовалось в тех случаях, когда метод может возвращать null вместо объекта, возвращать вместо объекта одинарный массив или список, заставляя тем самым пользователя API проверять, а содержится ли объект в этом массиве / списке.

Вместо подобной конструкции, использующей lazy оператор AND:
```java
if (object != null && object.getName().equals("Vovan loh")) {
    doSomething();
}
```
можно писать симпатично
```java
Optional.ofNullable(object)
    .filter(object.getName().equals("Vovan loh"))
    .ifPresent(() -> doSomething());
```

Также можно использовать Optional, если необходимо подменить какой-либо ресурс, который в результате предыдущих операций мог оказаться null:

```java
CustomObject result = Optional.ofNullable(object).orElseGet(CustomObject::new)
Такой подход позволяет не писать загромождающие код if'ы
CustomObject result = object;
if (result == null) {
    result = new CustomObject();
}
```

*Не рекомендуется:*
- Использовать Optional в сеттерах
- Заворачивать в Optional коллекцию или массив, лучше вместо этого передать пустую коллекцию или массив.
- Передавать Optional в виде одного из аргументов метода. Вместо этого лучше сделать перегруженный вариант этого метода, где аргумент будет отсутствовать.

*Рекомендуется:*
- Использовать Optional когда нужно показать, что какое-то возвращаемое значение может не иметь значения и это абсолютно нормально. В таком случае null в этом поле будет говорить об ошибке, а `Optional.empty()` о нормальном поведении. Это и есть главное предназначение Optional по задумке архитекторов Java.
- Использовать Optional там, где раньше были "магические числа (объекты)"
- В методах-генераторах данных. Например, при получении данных из БД.
- Использовать Optional для выборочного подключения зависимости к компоненту в рантайме.

---

**Недостатки Optional**

- Optional не реализует интерфейс `Serializible`, что ограничивает использование объектов типа `Optional` в качестве сериализованных данных.
- Некоторые фреймворки, использующие рефлексию, могут неверно сравнивать между собой объекты Optional. Jackson и Hibernate поддерживают его, но другие менее популярные библиотеки могут сломаться.

---

**Примитивные Optional**

По аналогии со стримами в стандартную библиотеку помимо обобщенного Optional были добавлены три его примитивные реализации:

- `OptionalInt`
- `OptionalLong`
- `OptionalDouble`

<mark>//Посмотреть что в них отличается от дженерика</mark>

---
## К изучению

- [X] javadoc на класс
- [ ] написать тесты на все методы и прикрепить сюда ссылку на репозиторий
- [X] Гайд по Optional от Oracle: https://www.oracle.com/technical-resources/articles/java/java8-optional.html
- [X] Анти-паттерны использования Optional: https://dzone.com/articles/java-8-optional-use-cases
- [X] Ответ архитектора Java по use-case'ам использования Optional: https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555
- [X] Серия статей: Объект в футляре или Optional в Java 8 и Java 9. (2018):
- [X] Часть 1. Введение: https://habr.com/ru/post/347480/
- [X] Часть 2. Методы Optional в Java 8: https://habr.com/ru/post/347576/
- [X] Часть 3. Методы Optional в Java 9: https://habr.com/ru/post/347748/
- [X] Часть 4. Творчество автора по улучшению Optional: https://habr.com/ru/post/347836/
- [X] Часть 5. Практические рекомендации по использованию Optional: https://habr.com/ru/post/350904/

- [X] Р. Уорбэртон - Лямбда-выражения в Java 8