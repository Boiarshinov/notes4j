---
title: "Строки - String"
tags:
  - core
  - text
draft: false
---

Класс `String` является immutable, это значит, что созданный объект не подлежит изменению. Другими словами, любые операции над строками не изменяют существующие строки, а производят новые.

Строки хранятся в кодировке UTF-16, т.к. UTF-16 строго ограничивает количество памяти на один символ - 16 бит. Благодаря этому строки могут представлять собой массив примитивов char.

Начиная с Java 9, строки могут представляться в памяти не только как массивы символов, но и как массивы байт. Благодаря этому нововведению, строки, хранящие в себе только латинские символы, начали занимать значительно меньше места в памяти, что положительно сказалось на быстродействии программ.

Примечание - правда из-за этого на 32-битных системах все строки выросли с 12 байт до 16. В 64-битных системах строки продолжили занимать 24 байта.

---
## String Pool

Из-за того что строки составляют преобладающую часть объектов на Java для их хранения придумали специальное место - String Pool.

Поэтому если создается новая строка, то происходит проверка на наличие в пуле такой строки, и если она существует, то переменной присваивается ссылка на существующую строку.
```java
String s1 = "abcd";
String s2 = "abcd"; //Программа видит, что такая строка уже есть в пуле и
                    //присваивает s2 ту же ссылку, что и s1
System.out.println(s1 == s2); //Поэтому результат - true
```

Если необходимо принудительно выделить место в памяти, то создавать строку нужно с помощью `new`
```java
String s1 = new String("abcd"); //будет принудительно выделено место в памяти
```

---
## Создание строк

- Обычно конструктор для строк не вызывается в явном виде, а переменной просто присваивается значение в следующем виде:
```java
String s1 = "abcd";
```

- `String(String)` - на основе строки создается новый объект
- `String(byte[])` - на основе массива байт, где каждые два байта - символ в кодировке Unicode
- `String(byte[], Charset)` - на основе массива байт в переданной кодировке
- `String(byte[], String)` - на основе массива байт в кодировке с переданным именем

## Операции над строками

- `boolean equals(String)` - сравнивает значения строк
- `boolean equalsIgnoreCase(String)` - сравнивает значения строк без учета регистра
- `String intern()` - проверяет наличие строки в пуле и возвращает ссылку на нее, если же такой строки там нет, то он ее там создает. Данным методом лучше не пользоваться, это ведет к просадкам производительности. Метод служит точкой входа в строку для системных оптимизиторов. Если очень хочется иметь быстрые строки для их ограниченного количества, лучше написать свою реализацию String Pool с использованием, например хэшмапы.
- `boolean contains(char c)` - проверяет наличие символа в строке, возвращает true или false
- `String substring(int start)` - возвращает строку обрезанную от исходной начиная со start
- `String substring(int start, int end)` - возвращает строку обрезанную от исходной начиная со start и заканчивая end
- `String toUpperCase()` - возвращает ту же строку, но со всеми прописными буквами
- `String toLowerCase()` - возвращает ту же строку, но со всеми строчными буквами
- `int length()` - возвращает количество символов в строке.
- `int charAt(int)` - возвращает символ, находящийся в строке на указанном месте
- `int indexOf(String)` - ищет в строке указанную подстроку и возвращает индекс её первого вхождения, если такой подстроки нет, то возвращает -1
- `int indexOf(String, int from)` - то же, что и прошлый, но начинает искать с переданного индекса
- `int lastIndexOf(String)` - ищет в строке указанную подстроку и возвращает индекс её последнего вхождения, если такой подстроки нет, то возвращает -1
- `int lastIndexOf(String, int from)` - то же, что и прошлый, но начинает искать с переданного индекса
- `int compareTo(String)` - сравнивает длины строк, если равны, то возвращает 0, если текущая меньше переданной, то возвращает отрицательное число, если больше, то положительное.
- `chars[] toCharArray()` - возвращает строку в виде массива символов
- `byte[] getBytes()` - возвращает строку в виде массива байт
- `byte[] getBytes(Charset)` - возвращает строку в виде массива байт в указанной [кодировке](charsets.md).
- `byte[] getBytes(String charsetName)` - возвращает строку в виде массива байт в кодировке с переданным именем
- `static String valueOf(primitive_type )` - преобразует в строку любой примитивный тип.
- `String trim()` - обрезает все пробелы в начале и в конце строки.
- Методы с [регулярками](regexp.md) под капотом:
    - `String[] split(String regex)` - нарезает строку в массив строк по регулярочке. Если в регулярке всего один символ, то работает значительно быстрее
    - `boolean matches(String regex)` - возвращает true, если в строка соответствует шаблону
    - `String replace(char, char)` - заменяет все символ, переданный в первом аргументе, на символ, переданный во втором аргументе, во всей строке.
    - `String replaceFirst(String regex, String replace)` - заменяет первое совпадения на указанную строку
    - `String replaceAll(String regex, String replace)` - заменяет все совпадения на указанную строку

Раньше не рекомендовалось конкатенировать строки с помощью оператора +, особенно в цикле, потому что это сильно сказывалось на производительности (создавалось большое количество строк, которые тут же ожидали своего уничтожения GC). Но в современных версиях Java компиляторы стали настолько умны, что самостоятельно преобразуют множественную конкатенацию в append'ирование с помощью `StringBuilder`.

---

Существуют еще два строковых класса, которые значительно упрощают работу со строками. Это StringBuilder и StringBuffer

### Класс `StringBuilder`

Класс не является immutable, поэтому его объекты можно изменять.
Конструкторы:

- `StringBuilder()` - создает объект с пустой строкой
- `StringBuilder(String)` - создает объект с переданной строкой

Методы:

- `void append(любые примитивные типы и String)` - добавляет в конец строки символьное представление примитива
- `void replace(int start, int end, String replace)` - заменяет указанную группу символов на новую строку. (end не включительно)
- `void deleteCharAt(int)` - удаляет из строки символ, находящийся на переданной позиции
- `void reverse()` - разворачивает строку задом наперед
- `String toString()` - преобразует объект в строку

**Внимание!!!** методы `equals()` и `hashCode()` в StringBuilder не переопределены! Использовать их нельзя!

### Класс StringBuffer

Класс является копией StringBuilder, но все его методы объявлены `synchronized`, что позволяет использовать его в многонитевых программах.

---
## Класс StringJoiner

Позволяет создавать строки с определенным разделителем при каждой дозаписи.
Класс не является immutable, поэтому его объекты можно изменять.
Конструктор:

- `StringJoiner(String)` - создает новый объект класса и устанавливает разделитель

Методы:
- `void add(String)` - добавляет новый элемент в строку, и вставляет между предыдущими символами и элементом разделитель

Пример:
```java
StringJoiner sj = new StringJoiner(", ");
for (int i = 0; i < 3; i++) sj.add("shake");
System.out.println(sj); //Вывод: shake, shake, shake
```

---
### Класс StringTokenizer

Класс StringTokenizer используется для разбиения строки на подстроки.

Класс давно уже объявлен legacy и его оставили в JDK только для поддержки старого кода. Вместо него рекомендуется использовать метод `split()` и регулярные выражения.

Конструкторы:

- `StringTokenizer(String s, CharSequence separators)` - передается строка, которая будет разбиваться на части, и набор символов, которые будут использоваться для разбиения. Каждый переданный символ выступает в качестве разделителя самостоятельно.

Методы:

- `boolean hasMoreToken()` - сообщает остались ли еще в строке токены
- `nextToken()` - возвращает следующий токен и отрезает его от строки, заложенной в токенайзер

---
## К изучению

- [X] https://javarush.ru/groups/posts/645-stroki-v-java
- [X] Про String Pool: https://www.baeldung.com/java-string-pool
- [X] Алексей Шипилев. Доклад про оптимизации класса String: https://www.youtube.com/watch?v=SZFe3m1DV1A&ab_channel=JUG.ru
- [X] Алексей Шипилев. Доклад про компактные строки: https://www.youtube.com/watch?v=HWkVJkoo1_Q&ab_channel=JUG.ru