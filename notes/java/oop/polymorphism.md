---
title: "Полиморфизм"
tags:
  - oop
draft: false
---

Полиморфизм — переопределение одних и тех же методов для объектов разных подклассов, наследованных от одного класса.

Одним из свойств полиморфизма является то, что в переменную типа родительского класса можно записывать ссылку на объект дочернего класса. Пример:
```java
ClassName name = new InheritantClass(); //
Animal dog1 = new Dog(); //класс Dog является дочерним для класса Animal, поэтому можно так написать
```

## Полиморфные массивы

Преимуществом полиморфизма является возможность создания массива из объектов разных дочерних классов и вызова в цикле унаследованных методов
```java
Animal[] animals = new Animal[3];
animal[0] = new Dog();
animal[1] = new Cat();
animal[2] = new Wolf();
for (int i = 0; i < animals.length; i++){
    animals.eat();
}
```

## Полиморфизм в методах

В методах можно указывать в качестве аргументов и типа возвращаемого значения также родительские классы, а запихивать (получать) потом туда классы-наследники.
```java
public void method (Animal a){
    a.makeNoise(); //классы-наследники будут выполнять свои перегруженные методы
}
//где-то в коде:
Dog pluto = new Dog();
method(pluto); //можем поместить в метод объект класса-наследника
```

## Ограничения полиморфизма

Методы, которые можно вызвать из объекта определяются тем, к какому классу принадлежит ссылочная переменная. Если переменная принадлежит родительскому классу, а записан в нее объект дочернего класса, то из нее можно вызвать методы объявленные в родителе, и методы, переопределенные в наследнике, но нельзя вызывать методы, свойственные только дочернему классу.
```java
class Animal {
    public void eat(){...}
}

class Dog extends Animal {
    public void bark() {...}
}

...
    Animal a = new Dog();
    a.bark(); //Ошибка!!! хоть объект и умеет это делать, но ссылочная переменная ему не позволяет
```

Для того чтобы использовать методы потомка, необходимо сузить тип ссылочной переменной. Для этого используют сужение с проверкой, иначе называемое downcast.
```java
if (a instanceof Dog) {
    Dog d = (Dog) a;
}
```

Если родительский метод переопределен в классе-наследнике, то при вызове его из переменной родительского типа, в которую записана ссылка на объект дочернего класса, будет вызван метод наследника:
```java
class Parent {
    public void method() { System.out.println("A"); }
}
class Son extends Parent {
    public void method() { System.out.println("B"); }
}
...
    Parent o = new Son();
    o.method(); //Будет выведено "B"
```