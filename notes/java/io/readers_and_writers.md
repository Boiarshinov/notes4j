---
title: "Потоки символов"
tags:
  - io
draft: false
---

Для работы с потоками символов существуют два основных класса: `Reader` и `Writer`

## Reader
Класс является абстрактным, хотя по сути он принадлежит к интерфейсам.

Методы:
- `int read()` - возвращает символьное представление следующего символа в потоке. Обрезает до 2 байт (размер char)
- `int read(char[])` - читает символы в переданный массив (пытается считать количество байт, равное размеру массива), возвращая число считанных символов
- `int read(char[], int from, int length)` - читает символы в количестве length в переданный массив, записывая их, начиная с индекса элемента массива from. Возвращает количество считанных символов
- `boolean ready()` - сообщает есть ли еще непрочитанные символы в потоке
- `long skip(long)` - пропускает указанное количество символов, возвращает количество пропущенных символов
- `void close()` - закрывает поток.
- `void mark(int)` - помещает в текущую часть потока метку, которая будет снята после прочтения указанного количества символов
- `void reset()` - возвращает указатель на метку
- `boolean markSupported()` - возвращает true, если методы `mark()` и `reset()` поддерживаются потоком

### Классы-наследники
- `InputStreamReader`
- `FileReader` - читает из файла (нельзя указать кодировку (в новых версиях Java уже можно))
- `CharArrayReader` - формирует поток из массива символов
- `StringReader` - формирует поток из строки
- `BufferedReader` - ридер с буферизацией. Можно читать целыми строками
- `FilterReader`
- `LineNumberReader` - входной поток, подсчитывающий строки
- `PipedReader`
- `PushbackReader`
- `StringReader` - преобразует строку в Reader, из которой можно что-либо считать

При открытии символьных потоков в их конструктор нужно пихать InputStream, при этом может указываться кодировка
```java
Reader reader = new InputStreamReader(inputStream, "UTF-8");
```

В переносимых программах обязательно нужно указывать кодировку, т.к. системная может отличаться от системы к системе.

## Класс Writer
Класс является абстрактным, хотя по сути он принадлежит к интерфейсам.

Методы:
- `void write(char)` - записывает символ в поток
- `void write(char[])` - записывает массив символов в строку
- `void write(char[], int from, int length)` - записывает указанную часть массива символов в строку
- `void write(String)` - записывает в поток строку в виде массива символов
- `void flush()` - кидает в поток все элементы из буфера
- `void close()` - закрывает поток

### Классы-наследники
- `OutputStreamWriter`
- `PrintWriter` - обеспечивает форматированный вывод
- `FileWriter` - записывает с файл (нельзя указать кодировку)
- `CharArrayWriter` - удобно использовать для тестирования программ
- `StringWriter` - удобно использовать для тестирования программ
- `BufferedWriter` - буферизированная читалка
- `FilterWriter`
- `PipedWriter`
- `StringWriter` - позволяет записывать поток символов, а потом преобразовывать его в строку

При открытии символьных потоков в их конструктор нужно пихать OutputStream, при этом может указываться кодировка
```java
Charset charser = StandardCharsets.UTF_8;
Writer writer = new OutputStreamWriter(outputStream, charset); //Можно и строкой, как выше
```

В переносимых программах обязательно нужно указывать кодировку, т.к. системная может отличаться от системы к системе.

---
## [Кодировки](../charsets.md) 
- `UTF-8` - от 1 до 4 байт. Может представить любой символ Юникода (Unicode)
- `UTF-16` - от 2 или 4 байта на символ.
- `CP-866` - 1 байт на символ, имеет кириллические символы
- `ASCII`

---
## BufferedReader
В класс добавлены следующие методы:
- `String readLine()` - возвращает строку, считанную из файла. Символ переноса строки не возвращается, если читать нечего, то возвращает null
- `Stream<String> lines()` - возвращает стрим строк.

Создать ридер можно с использованием старых и новых технологий:
```java
BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(filename)), "UTF-8"); //старый способ
BufferedReader reader = Files.newBufferedReader(Paths.get(filename), "UTF-8");
```

## BufferedWriter
В класс добавлены следующие методы:
- `void newLine()` - добавляет в поток разделитель строки для платформы, с которой вызывается

---
## PrintWriter
Является наследником Writer.

Конструкторы:
- `PrintWriter (Writer)` - принимает объект типа Writer или его наследников

Методы:
- `void print(что-угодно)` - выводит в поток что-угодно
- `void println(что-угодно)` - выводит в поток что-угодно и символ переноса строки
- `PrintWriter printf(String format, Object... args)` - выводит в поток что-угодно, [formatting](../formatting.md) по заданному шаблону.  
- `boolean checkError()` - проверяет наличие ошибки

ВАЖНО: методы не бросают исключения, вместо этого они устанавливают флаг ошибки, который проверяется с помощью метода `checkError()`

---
## StringTokenizer
Простенький класс, позволяющий разбирать поток на строки (числа распознавать не умеет).

Класс уже устарел и не рекомендуется к использованию.

---
## Scanner

Методы:
- `useDelimeter(String regex)` - устанавливает шаблон разделителя, который нарезает входные данные на токены. По умолчанию это пробелы
- `useLocale(Locale)` - устанавливает локаль (при установке русской локали сканнер сможет распознавать числа с запятой в качестве десятичного разделителя)
- `String next()` -
- `boolean nextBoolean()` -
- `double nextDouble()` -
- `Integer nextInt()` -

---
## StringReader
Класс позволяет преобразовать строку в символьный поток, из которого можно что-нибудь считать.
Это позволяет использовать его для тестирования своих методов, которые должны считывать что-либо из символьных потоков.

Конструкторы:
- `StringReader(String)` - кладем в ридер строку и она чудесным образом становится символьным потоком вывода

## StringWriter

Класс позволяет записать в его объект поток символов, а потом с легкостью преобразовать их в строку.

Конструкторы:
- `StringWriter()` - пустой

Методы:
- `void write(String)` - записывает в поток строку
- `String toString()` - возвращает все записанные символы в виде одной строки.