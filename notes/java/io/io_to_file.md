---
title: "Ввод-вывод в файлы"
tags:
  - io
draft: false
---

Для ввода и вывода в файлы существует два основных класса `FileInputStream` и `FileOutputStream`

**Класс FileInputStream**

Читает содержимое файлов побайтово
Конструкторы:

- `FileInputStream(String)` - создает читалку для файла с расположением, указанным в аргументе
- `FileInputStream(File)` - создает читалку для файла с расположением, указанным в аргументе

Методы:
- `int read()` - читает один байт и возвращает его
- `int available()` - возвращает количество непрочитанных байт
- `void close()` - закрывает поток

**Класс FileOutputStream**

Записывает информацию в файл побайтово.

Конструкторы:

Конструкторы могут принимать строки или файлы. Если в конструктор больше ничего не передавать, то каждый раз при создании потока файл будет перезаписываться и все предыдущие данные будут удаляться. Для того чтобы дозаписать данные в существующий файл есть специальные конструкторы с дополнительным параметром типа boolean

- `FileOutputStream(String)` - создает записывалку для файла с расположением, указанным в аргументе
- `FileOutputStream(String, boolean)` - то же, что и предыдущий, не еще можно включить дозаписывание
- `FileOutputStream(File)` - создает записывалку для файла с расположением, указанным в аргументе
- `FileOutputStream(File, boolean)` - то же, что и предыдущий, но еще можно включить дозаписывание

Самое классное - если файла с таким расположением не существует, то он создается автоматически!!!

Методы:
- `void write(int)` - записывает в файл данные. Данные обрезаются до одного байта
- `void flush()` - заставляет срочно записать всю информацию, имеющуюся в буфере
- `void close()` - закрывает поток

**Буферизированные обертки**
**Класс BufferedInputStream**

Класс является оберткой для InputStream, но с большим успехом работает также с FileInputStream.

Конструкторы:
- `BufferedInputStream(InputStream, int bufferSize)` - передается поток записи и размер буфера
- `BufferedInputStream(InputStream)` - размер буфера по умолчанию 8 кБ

Методы:
- те же, что и у `FileInputStream`

**Классы FileReader и FileWriter**

Классы существуют, но они не позволяют указать кодировку, поэтому их использование не рекомендуется.

Вместо них лучше использовать такие конструкции:
```java
Reader reader = new InputStreamReader(new FileInputStream("in.txt"), "UTF-8");

Writer writer = new OutputStreamWriter(new FileOutputStream("out.txt"), "UTF-8");
```

UPD: уже позволяют использовать кодировку.

---

**Класс RandomAccessFile**
Класс позволяет одновременно и читать из файла и записывать в него.

Класс не унаследован от InputStream и OutputStream. Но зато он реализует интерфейсы DataInput и DataOutput

Конструкторы:
- `RandomAccessFile(String filename, String access)` - Открывает файл для совершения операций, определяемых модификатором. Возможные значения модификатора:
    - `r` - читать
    - `rw` - и читать, и писать
    - `rws` - и читать, и писать. Все изменения файла сразу сохраняются на физический носитель

```java
RandomAccessFile raf = new RandomAccessFile("input.txt", "r"); //только на чтение
```

Методы:

- `void seek(long)` - устанавливает указатель в переданную позицию (в байтах)
- `long getFilePointer()` - возвращает текущее положение курсора
- `int read()` - читает байт с текущего положения курсора и возвращает значение байта
- `int readInt()`
- для всех примитивных типов
- `String readLine()` - читает от текущего положения курсора до конца строки
- `void readFully(byte[])` - читает весь файл в массив байт
- `void write(byte)` - перезаписывает байт, находящийся на текущем положении курсора
- `void writeInt(int)`
- для всех примитивных типов
- `void writeBytes(String)` - перезаписывает информацию в файле на переданную, начиная с текущего положения курсора. Будет заменено столько символов, сколько было в строке. Если курсор находится в конце файла, то файл будет удлиняться
- `void close()` - закрывает поток

Проблема данного класса заключается в том, что при записи строк ты никогда не знаешь сколько места они займут, потому что строки в Java кодируются в UTF-16, в котором символ может занимать либо 2, либо 4 байта