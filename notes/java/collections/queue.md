---
title: "Очереди - Queue"
tags:
  - collections
draft: false
---

Очереди относятся к [коллекциям](collections.md).

## Интерфейс `Queue<E>`

Очереди работают точно так же, как и в реальной жизни: первый встал в очередь, первым из нее и выйдешь - FIFO - first in, first out.

Методы:
- `boolean add(E)` - добавляет элемент в хвост очереди, если очередь заполнена, то кидает исключение
- `boolean offer(E)` - добавляет элемент в хвост очереди, если очередь заполнена, то возвращает false
- `E remove()` - извлекает первый элемент из головы очереди, если очередь пуста, то кидает исключение
- `E poll()` - извлекает первый элемент из головы очереди, если очередь пуста, то возвращает null
- `E element()` - возвращает первый элемент из головы очереди, не удаляя его. Если очередь пуста, то кидает исключение
- `E peek()` - возвращает первый элемент из головы очереди, не удаляя его. Если очередь пуста, то возвращает null


---
## Блокирующая очередь
Для работы с потоками данных может пригодиться очередь `BlockingQueue`.
Основная фишка этой очереди в том, что она может блокировать поток исполнения при добавлении или извлечении элементов.
Для этого в интерфейс были добавлены новые методы:
- `put(E)` - пытается положить элемент в очередь. Если очередь заполнена, то поток исполнения блокируется пока в очереди не появится место, чтобы положить туда элемент
- `take()` - пытается достать из очереди элемент. Если очередь пуста, то поток исполнения блокируется пока в очереди не появится новый элемент, который можно забрать

Также такие очереди являются потокобезопасными, а значит в них можно спокойно писать и читать из нескольких тредов.

Если требуется падать по таймауту, когда блокировка происходит слишком долго, то можно использовать отдельные методы `offer()` и `poll()`.

Блокирующие очереди часто используются в [pub-sub архитектурах](../../architecture/pub_sub.md), когда один тред публикует события, а другие треды их вычитывают.

Интерфейс `BlockingQueue` наследует `Queue`.
Основной реализацией является `ArrayBlockingQueue`, хотя существует и множество других.


## Интерфейс `Deque<E> extends Queue<E>`
Можно добавлять и забирать элементы как с начала, так и с конца очереди
Методы:
- `void addFirst(E)`
- `void addLast(E)`
- `boolean offerFirst(E)`
- `boolean offerLast(E)`
- `E pollFirst()` - возвращает первый элемент в очереди
- `E pollLast()` - возвращает последний элемент в очереди
- `E removeFirst()`
- `E removeLast()`

Реализации интерфейса:
- Класс `ArrayDeque<E>`
- Класс `LinkedList<E>` (Бум! вот это неожиданно!)

---
## К изучению
- [ ] http://tutorials.jenkov.com/java-util-concurrent/blockingqueue.html