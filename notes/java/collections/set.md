---
title: "Множества - Set"
tags:
  - core
  - collections
draft: false
---

Множества относятся к [коллекциям](collections.md).

## Set-коллекции 
Множество уникальных элементов хранящихся неупорядоченно.
Все элементы в Set уникальны

Основные представители:
- `HashSet` - множество на основе хэш-таблицы
- `LinkedHashSet` - множество на основе хэш-таблицы, но при этом элементы извлекаются итератором в том порядке, в котором были туда положены
- `SortedSet` - множество, в котором элементы расположены по возрастанию
    - `TreeSet`

## Интерфейс `Set<E>`

Интерфейс не добавляет новых методов относительно родительского интерфейса, но немного уточняет их

Методы:
- `boolean add()` - добавляет новый элемент в множество. Если такой элемент уже есть, то возвращает false
- `addAll()`
- `remove()`
- `removeAll()`
- `boolean contains(E)`
- `boolean containsAll()`
- `int size()` - возвращает количество элементов в коллекции
- `boolean equals(Set<E>)` - сравнивает два множества по содержимому

## Класс `HashSet<E> implements Set<E>`

Реализация множества на основе хэш-таблицы. Очень важно, чтобы у класса, объекты которого помещаются во множество, были согласованы метода `equals()` и `hashcode()`.

Объект, лежащий во множестве, не должен менять поля, которые влияют на работу методов `equals()` и `hashcode()`, иначе это грозит катастрофой.

Итератор обходит элементы по номерам хэш-таблицы
Методы:

## Интерфейс `SortedSet<E> extends Set<E>`

В данном множестве элементы располагаются (и извлекаются итератором) по возрастанию.

Для того чтобы элементы могли выстраиваться по возрастанию, их класс должен реализовывать интерфейс `Comparable<T>`

Методы:
- `SortedSet<E> headSet(E)` - возвращает подмножество элементов, меньших, чем переданный
- `SortedSet<E> tailSet(E)` - возвращает подмножество элементов, больших, чем переданный
- `SortedSet<E> subSet(E from, E to)` - возвращает подмножество элементов
- `E first()` - возвращает наименьший элемент
- `E last()` - возвращает наибольший элемент

## Класс `TreeSet<E> implements Set<E>`

Внутри находится самобалансирующееся двоичное дерево поиска - красно-черное дерево

Конструкторы:
- `TreeSet<>()` - пустой конструктор, класс вложенных объектов должен реализовывать интерфейс `Comparable<T>`
- `TreeSet<>(Comparator<T>)` - передается компаратор для сравнения объектов