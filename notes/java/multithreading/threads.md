---
title: "Нити Threads"
tags:
  - multithreading
draft: false
---

Для того чтобы получить возможность вызывать методы в новом потоке необходимо чтобы класс, в котором находится этот метод реализовывал интерфейс Runnable и его метод run(). В методе run() прописываются команды для выполнения в новом потоке.

Для того чтобы запустить новый поток, нужно создать новый объект класса Thread и передать в конструктор в качестве аргумента ссылку на объект класса, реализующего интерфейс Runnable.
```java
class MyClass implements Runnable {
    void run(){

    }
}

class Test{
    public static void main(String[] args){
        MyClass example = new MyClass();
        Thread thread1 = new Thread(example);
        thread1.start();
    }
}
```

Как вариант можно наследовать интересующий класс от класса Thread, но тогда его нельзя унаследовать ни от чего больше.

## Интерфейс Runnable

Интерфейс имеет всего один нереализованный метод, поэтому относится к [функциональным интерфейсам](../stream_and_lambda/functional_interface.md)

- `void run()` - одним из недостатков этого метода является то, что он не допускает выбрасывания проверяемых исключений

## Класс Thread implements Runnable

У каждой нити есть состояние, в котором она находится. Состояние описывается с помощью внутреннего перечисления State. Подробнее о состояниях [здесь](thread_lifecycle.md).

Конструкторы:
- `Thread(Runnable)` - принимает объект класса, реализующего интерфейс Runnable
- `Thread(Runnable, String name)` - принимает объект класса, реализующего интерфейс Runnable, и имя нити
- `Thread()` - начинает выполнять свой внутренний метод `run()`

Поля:
- `String name` - имя нити
- `boolean isInterrupted` - прервана ли нить

Методы:
- `void start()` - запускает новый поток
- `final void join()` - та нить, в которой вызван метод, ждет завершения той нити, через точку которой вызван метод. Нить переходит в состояние WAITING
- `final void join(long)` - та нить, в которой вызван метод, ждет завершения той нити, через точку которой вызван метод. Если время в мс, переданное в параметре, вышло, то нить разблокируется. Нить на время переходит в состояние TIMED_WAITING
```java
thread1.join(); //основная нить ждет пока закончится выполнение нити thread1
```
- `static void sleep(long)` - нить приостанавливается на количество миллисекунд, указанное в аргументе, и переходит в состояние `TIMED_WAITING`. *Важно!* метод статический и поэтому вызывается не для той нити, из которой вызван, даже если был вызван через точку у другой нити
```java
public static void main(String[] args){
    Thread thread = new Thread(){ void run() {
        for(int i = 0; i < 99999999; i++) i * i;
    };
    thread.start();

    thread.sleep(); //Заснет главная нить, а не thread, потому что метод статический!

}
```

- `static void yield()` - процесс уступает процессорное время другим нитям. Равнозначно написанию Thread.sleep(0); Нить переходит из состояния RUNNING в состояние READY. *Важно!* метод статический и поэтому вызывается для той нити, из которой вызван, даже если был вызван через точку у другой нити
- `final void setPriority(const)` - устанавливает приоритет выполнения нити
- `final int getPriority()` - возвращает приоритет выполнения нити.
- `void interrupt()` - устанавливает флаг прерывания нити в true. Она прервется при первом же вызове sleep()
- `boolean interrupted()` - возвращает значение флага прерывания текущей нити и устанавливает его в false
- `boolean isInterrupted()` - возвращает значение флага прерывания той нити, из которой он вызван
- `static Thread currentThread()` - возвращает текущую нить, из которой можно вызвать методы
- `final boolean isAlive()` - возвращает true, если поток ещё выполняется.
- `final String getName()` - возвращает название нити.
- `void setUncaughtExceptionHandler(UncaughtExceptionHandler)` - устанавливает обработчик неотловленных ошибок для потока 
- `void setDaemon(boolean)` - устанавливает режим демона для нити. Метод можно вызывать только до запуска нити

![thread interruption](../../../images/thread_interruption.png)

Спящий поток можно прервать с помощью метода interrupt(), при этом он выкинет исключение InterruptedException.

После того как поток проснулся он не обязательно тут же приступает к работе - планировщик потоков мог отдать приоритет какому-либо другому потоку.

Приоритет выполнения нити определяется константой, значение которой может быть в пределах от 1 до 10. Наименования констант:
- 1 - MIN_PRIORITY
- 5 - NORM_PRIORITY
- 10 - MAX_PRIOTITY
```java
myThread.setPriority(NORM_PRIORITY + 3);
```

## Синхронизация и непостоянность

Для синхронизации работы нитей с объектами используется ключевое слово `synchronized`. Подробнее про него тут:  [Модификаторы (ключевые слова)](evernote:///view/170585988/s440/fe935efd-1a91-4176-b80d-7d1f4814d13d/fe935efd-1a91-4176-b80d-7d1f4814d13d/)

При расчетах компьютер для быстроты подгружает данные из постоянной памяти в кэш. При многонитевости из-за того, что данные находятся в кэше и меняются там же, разные нити могут работать в разными версиями одного и того же объекта. Чтобы запретить объекту загружаться в кэш используется ключевое слово `volatile`. Подробнее про него тут:  [Модификаторы (ключевые слова)](evernote:///view/170585988/s440/fe935efd-1a91-4176-b80d-7d1f4814d13d/fe935efd-1a91-4176-b80d-7d1f4814d13d/)

Еще одной фишкой volatile является то, что при записи новых данных в переменную, объявленную с таким модификатором, в постоянной памяти обновляется все, что было в кэше.
```java
int a, b;
volatile int c;
a = 5; b = 10; //Новые значения переменных хранятся в кэше
c = 15; //Значение с сразу записано в память, также из кэша в память выгружены значения a и b
```

## Проблемы многопоточности
Многопоточность создает несколько проблем:
- Взаимная блокировка (deadlock) - ситуация, когда процессы не могут завершиться, потому что ждут результатов выполнения друг друга.
- Состояние гонки (race condition)
- Динамическая взаимоблокировка (livelock)
- Голодание (starvation) - поток не может получить доступ к совместно используемым ресурсам

## Аннотирование многопоточных классов
- `@ThreadSafe` - класс безопасен для его многопоточного использования
- `@NotThreadSafe` - класс небезопасен для его многопоточного использования

## Монитор
Монитор контролирует доступ к объекту. Если доступ к объекту осуществляется из синхронизированного метода, то монитор блокирует доступ к данному объекту из других потоков.

<mark>//Описание synchronized</mark>

Объект, который находится в скобках синхронизированного блока названия мьютексом. <mark>*Это не правильно!*</mark>

Если метод объявлен синхронизированным, то это равносильно тому, что все тело метода заключено в блок synchronized с мютером this

Для статических методов синхронизация ведется по классу:
```java
class MyClass{

    public static synchronized void method(){ ... } //эта строка равносильна тому, что ниже

    public static void method(){
        synchronized (MyClass.class) { ... }
    }
}
```

## Многонитевость в классе Object
В классе Object существуют методы для работы с многопоточностью:

- `final void wait()` - поток, в методе которого вызван wait(), приостанавливается, давая возможность другим потокам поработать с объектом до получения уведомления с помощью notify(). Нить переходит в состояние WAITING. Метод wait() настоятельно рекомендуется вызывать в цикле while, а не в условии.
- `final void wait(long)` - ожидание длится указанное количество миллисекунд или до получения уведомления
- `final void wait(long, int)` - ожидание длится указанное количество миллисекунд и наносекунд.

Методы `wait()` вызываются из синхронизированных методов для временного снятия блокировки объекта.

Все методы `wait()` кидают `InterruptedException`.

Рекомендуется вызвать `wait()` из цикла с проверкой условия перехода в режим ожидания

- `final void notify()` - возобновляется выполнение одного ожидающего потока. Рекомендуется использовать для оптимизации, если не хочется париться с дополнительными проблемами, пожертвовав немного быстродействием, то рекомендуется использовать notifyAll().
- `final void notifyAll()` - возобновляется выполнение всех ожидающих этот объект потоков.

*ВАЖНО!* Все перечисленные методы можно вызвать только внутри блока synchronized у объекта, мьютекс которого был заблокирован текущей нитью.

---
## К изучению
- [ ] Про threads в 6 частях: https://javarush.ru/groups/posts/2047-threadom-java-ne-isportishjh--chastjh-i---potoki
- [X] https://www.ibm.com/developerworks/ru/library/l-java_universe_multithreading_tasks/index.html