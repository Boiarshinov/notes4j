---
title: "Барьеры"
tags:
  - multithreading
  - concurrency
draft: false
---

# Барьеры

Барьер - это такой паттерн, при котором группа потоков останавливается в какой-то общей точке, а потом одновременно проходят дальше при выполнении какого-либо условия или наступления некоторого события.

В Java 5 были добавлены классы, реализующие данный паттерн:
- `CountDownLatch`
- `CyclicBarrier`
- `Phaser`

Барьеры редко используются в боевом коде, из-за того, что потоки блокируются в точке синхронизации и не занимаются какой-либо полезной работой.
Поэтому основная область их применения - тестирование.

---
## CountDownLatch

Класс создан для того, чтобы заменить неудобные wait и notify на что-то более компактное.
Удобно использовать, когда нужно одновременно запустить несколько потоков.

![CountDownLatch animation](../../../images/countdownlatch_animation.gif)

При создании `CountDownLatch` устанавливается количество раз, которое должен быть вызван метод `countDown()` для того чтобы метод `await()` завершился:
```java
var latch = new CountDownLatch(1);
```

Методы:
- `void await()` - ожидает, пока метод countDown() не будет вызван то количество раз, которое было передано в конструктор
- `boolean await(long timeout, TimeUnit)` - то же, но гарантированно разблокируется спустя указанное время
- `void countDown()` - уменьшает на единицу счетчик, приближая к завершению метод `await()`. Когда счетчик дойдет до нуля, защелка откроется.
- `int getCount()` - сколько раз еще нужно вызвать `countDown()`, чтобы защелка открылась.

Важно понимать, что в сценарии использования `CountDownLatch` обязанности разделены: одни потоки заблокированы в методе `await()`, а другие потоки дергают `countDown()`, чтобы довести счетчик до нуля.

Пример использования: допустим мы хотим смоделировать гонку потоков: нам нужно сначала подготовить потоки, а потом одновременно их запустить:
```java
var latch = new CountDownLatch(1);
Runnable task = () -> {
    try {
        latch.await(); //All threads will wait here until latch will open
    } catch (InterruptedException ignored) {
    }
    doJob();
};
new Thread(task).start();
new Thread(task).start();
new Thread(task).start();
latch.countDown();
```

`CountDownLatch` применяется в случаях:
- Ожидание завершения работы подзадач (подходит только при низкой нагрузке)
- Ожидание загрузки компонентов при старте приложения (аналог спрингового `@PostConstruct`)
- Нагрузочные тесты

Минус `CountDownLatch` в том, что он одноразовый, но существует `CyclicBarrier`.


---
## CyclicBarrier

`CyclicBarrier` очень похож на `CountDownLatch`, но уменьшение счетчика происходит автоматически, когда очередной поток вызывает метод `await()`, и барьер можно восстановить с помощью метода `reset()`.

![CyclicBarrier animation](../../../images/cyclicbarrier_animation.gif)

Количество потоков, которые должны вызвать `await()`, чтобы барьер открылся, указывается в конструкторе.
Также в конструкторе можно передать лямбду, которая будет вызвана сразу после открытия барьера в потоке, последним вызвавшем `await()`.
```java
var barrier = new CyclicBarrier(3, () -> log.debug("Barrier have fallen"));
```
- `CyclicBarrier(int count, Runnable)` - задает количество вызовов await после которого барьер будет сломан

Методы:
- `void await()` - уменьшает на единицу счетчик вызовов и ждет, когда сломается барьер
- `void reset()` - сбрасывает счетчик барьера к первоначальному значению. Если при вызове метода у барьера стояли потоки, то они получают исключение `BrokenBarrierException`, а барьер переводится в состояние `broken`
Для мониторинга состояния барьера есть методы:
- `int getNumberWaiting()` - количество потоков, уже вызвавших `await()` и ожидающих открытия барьера.
- `int getParties()` - количество потоков, которые должны вызвать `await()`, чтобы барьер открылся. Число, заданное в конструкторе
- `boolean isBroken()` - true, если при вызове `reset()` от барьера отвалились ожидающие потоки.


`CyclicBarrier` внутри устроен с помощью обычного [лока](./locks.md) `ReentrantLock`, производного от него `Condition` и счетчика потоков.

В связи с тем, что барьер может перейти в сломанное состояние при некорректной работе с потоками, бывает проще создавать каждый раз новый барьер, вместо того, чтобы переиспользовать один и тот же.
`CyclicBarrier` пригодится в:
- тестирование конкуренции между потоками
- эмуляция дедлоков


---
## Phaser

Класс `Phaser` - это тоже барьер, но более гибкий:
- можно менять количество участников от фазы к фазе;
- есть как блокирующие, так и неблокирующие методы;
- можно добавить действие при завершении фазы

![phaser animation](../../../images/phaser_animation.gif)

Конструкторы:
- `Phaser()` - пустой
- `Phaser(int parties)` - указывается количество участников

Методы:
- `register()` - регистрирует тот поток, из которого вызван метод
- `int arriveAndAwaitAdvance()` - указывает, что поток закончил выполнять фазу. Поток приостанавливается и ждет пока другие потоки тоже закончат выполнение фазы. Возвращает номер текущей фазы
- `int arrive()` - сообщает, что поток закончил выполнять фазу. Поток не останавливается, а продолжает работу. Возвращает номер фазы
- `int arriveAndDeregister()` - сообщает, что он завершил выполнять все фазы и снимается с регистрации. Возвращает номер фазы.
- `int awaitAdvance(int phase)` - если phase равно номеру текущей фазы, то поток приостанавливается до ее завершения.
- `int getPhase()` - возвращает номер текущей фазы

`Phaser` задумывался, как механизм многоэтапных вычислений.
Но оказался слишком накрученным и сложным для восприятия.
Поэтому он почти не используется

---
## К изучению
- [X] Про [CountDownLatch](https://www.youtube.com/watch?v=XkAjmCIY2WI&feature=youtu.be&t=798) 30:12
- [ ] Про синхронизаторы: https://habr.com/ru/post/277669/
- [ ] Про Phaser: https://habr.com/ru/post/117185/
- [X] [Курс по многопоточности в Java](https://fillthegaps.getcourse.ru/mt7)