---
title: "Пулы нитей"
tags:
  - multithreading
draft: false
---

Нижеперечисленные классы и интерфейсы используются в многонитевости и включены в API `java.util.concurrent`.

## Интерфейс ExecutorService
Класс представляет собой усовершенствованную реализацию шаблона `WorkerThread`.

Новые экземпляры, реализующие интерфейс создаются с помощью утилитного класса `Executors` (см. ниже)

```java
ExecutorService service = Executors.newFixedThreadPool(2);
```

Методы:
- `Future submit(Callable)` - задача ставится в очередь на выполнение. Возвращается Future, через который можно узнать выполнена ли задача с помощью isDone() и получить результат выполнения с помощью get()
- `Future submit(Runnable)` - то же самое
- `void shutdown()` - закрыть все нити (будут закрыты, когда выполнится последняя задача)
- `List<Runnable> shutdownNow()` - запрещает всем нитям брать новые задачи, даже если в очереди еще есть задачи, пытается прервать все текущие нити и возвращает список задач, которые никогда не будут выполнены.
- `void awaitTermination(long, TimeUnit)` - выжидает указанное количество времени прежде чем завершить работу всех нитей.

Реализации:
- `FixedThreadPool` - фиксированное количество нитей
- `CachedThreadPool` - кэшируемый пул нитей
- `ThreadPoolExecutor` - пул, который может немного растягиваться (до максимального значения)

---
## Класс Executors

Класс утилитный и служит для создания различный исполнителей задач (пулов нитей)

Методы:

- `newFixedThreadPool(int nThread)` - создает пул нитей с указанным количеством нитей
- `newCachedThreadPool()` - создает кэширующий пул нитей, который создает нити по мере необходимости

---
## Класс ThreadPoolExecutor

Так как создание новой нити - очень ресурсозатратная задача, то зачастую гораздо более эффективным будет создание ограниченного числа нитей и решения возникающих задач в этих нитях, при этом, если задач больше, чем нитей, то задачи ставятся в очередь.

При добавлении новой задачи она помещается в конец очереди.
Если новых задач нет, то неработающие нити засыпают.
Если очередь заполнено, то выкидывается исключение.
Количество нитей в пуле подбирается эмпирическим путем.
Класс ThreadPoolExecutor реализует интерфейс ExecutorService, о котором ниже.

Конструкторы:

- Существуют конструкторы, но лучше создавать конкретную реализацию с помощью методов класса Executors (о нем ниже)
- `ThreadPoolExecutor(int coreThreads, int maxPoolSize, long keepAlive, TimeUnit, BlockedQueue)` - устанавливает количество начальное количество нитей, их максимальное количество, максимальное время выполнения нитью задачи и подключает к пулу очередь задач.

Когда в пул приходит новая задача, она ставится в очередь. Если максимум количества нитей еще не достигнут, то создается новая нить и она приступает к выполнению задачи. Если максимум количества нитей уже достигнут, то будится спящая нить и ей поручается выполнение задачи. Если все нити заняты, то задача ждет в очереди.

Методы:
- все методы `ExecutorService`
- `void prestartAllCoreThreads()` - запускает на выполнение все нити с загруженными задачами

---
## Интерфейс `Callable<V>`

Данный интерфейс является [функциональным](../stream_and_lambda/functional_interface.md) и очень похож на `Runnable`, но его метод `call()`, в отличие от `run()` возвращает результат. Тип возвращаемого результата указывается в обобщении.

- `V call()` - возвращает результат типа, указанного в обобщении

В случаях, когда хочется использовать `Callable`, но метод `call()` не должен ничего возвращать, можно сделать в обобщение поставить класс `Void`, тогда всем сразу будет понятно, что метод ничего не возвращает.

---
## Интерфейс `Future<V>`

Интерфейс обобщенный, в обобщении указывается тип возвращаемого значения метода `get()`.

Методы:
- `boolean cancel(boolean)` - пытается остановить выполнение задачи
- `V get()` - ждет при необходимости окончания вычислений и возвращает результат
- `V get(long timeout, TimeUnit unit)` - ждет указанное время окончания вычислений, и если они успевают выполниться, то возвращает результат
- `boolean isCancelled()` - возвращает true, если выполнение задачи отменено
- `boolean isDone()` - возвращает true, если задача выполнена

---
## Класс `FutureTask<V>`
Класс нужен для создания задач, которые будут выполнены в будущем.

Конструкторы:
- `FutureTask(Callable<V>)` -
- `FutureTask(Runnable, V result)` -

Помимо методов, определенных в Future, класс предоставляет еще следующие методы:

- `void done()` - метод, который выполняется, когда статус задачи становится isDone
- `void run()` -
- `boolean runAndReset()` -
- `void set(V)` - устанавливает результат, возвращаемый при выполнении задачи
- `void setException(Throwable)` - устанавливает исключение, которое будет являться причиной выкинутых исключений при исполнении задачи.

---
## К изучению

- [X] https://javarush.ru/groups/posts/2065-threadom-java-ne-isportishjh--chastjh-iv---callable-future-i-druzjhja
- [X] https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html
- [X] https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html
- [X] https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html
- [ ] https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html
- [ ] https://winterbe.com/posts/2015/04/07/java8-concurrency-tutorial-thread-executor-examples/
- [ ] https://habr.com/ru/post/116363/