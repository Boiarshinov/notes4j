---
title: "ThreadSafe - нитебезопасность"
tags:
  - multithreading
draft: false
---

# Потокобезопасность (нитебезопасность)

[Нити](./threads.md) при одновременной работе могут совместно читать и менять один объект. 
Для того чтобы изменения, вносимые одной нитью, воспринимались другой нитью, необходимо обеспечить нитебезопасность объекта.

Существует радикальный подход к потокобезопасности, когда приложение вообще не использует общих переменных.
Этот подход называется `thread confinement`.
Но он слабо реализуем в Java, т.к. метод `Thread.run()` не возвращает результата.
А значит, чтобы получить результат работы кода, запущенного в отдельном потоке, придется использовать общие переменные.

У каждого объекта есть мьютекс, предназначенный для работы в многопоточности. 
Мьютекс свидетельствует о том, занят ли в настоящий момент объект каким-либо потоком. 
Если поток захватил мьютекс объекта, то остальные потоки не смогут работать с этим объектом. 
Мьютекс захватывается с помощью ключевого слова `synchronized`.

![404 not found. TODO - replace](https://javarush.ru/api/1.0/rest/images/1293665/ac785bbd-16cf-4830-bf96-8dbfd84b3cbc?size=0)

Мьютекс - по сути boolean переменная, которая говорит о том, занят ли сейчас объект. `true` - занят, `false` - свободен.

Монитор - надстройка, которая позволяет выполнять блок кода, только если мьютекс объекта свободен. Монитор реализуется с помощью ключевого слова synchronized.

Блок / модификатор synchronized
- для метода - *блокирует объект, из которого вызван метод*, для других нитей до окончания выполнения метода (ни один синхронизированный метод этого объекта не может быть вызван из другой нити до конца выполнения метода)
- как блок/метод - `synchronized(Object) {}` - блокирует объект, указанный в скобках и выполняет код в фигурных скобках.

Пример блока synchronized:
```java
synchronized(object) {
    object.doJob();
}
```
Как это работает на пальцах:
```java
while (object.mutex) Thread.sleep(1);
object.mutex = true;
object.doJob();
object.mutex = false;
```

## Способы достижения потокобезопасности

- Объявить все методы класса, которые могут привести к конфликту нитей, с модификатором synchronized
- Сделать класс Immutable
- Если не хочется блокировать весь объект, то можно создать замки на методах:

```java
class MyClass{
    private int a, b;
    private final Object lock = new Object(); //замок (обязательно нужно создавать финальный объект)
    public int sumOfTwo(){
        synchronized(lock){ //Весь объект не будет заблокирован, будет блокирован только этот метод
            return a + b;
        }
    }
}
```

- Использование атомарных операций. Для совершения атомарных операций над примитивами и объектами существуют [атомарные классы](../atomic.md)

---
## Подходы к блокировке

### Оптимистический
В оптимистическом подходе при выполнении операций блокируются только те данные, которые могут быть изменены в разных потоках. 
Также оптимистичным подходом называется ситуация, когда сначала без блокировки выполняется полезная работа в локальных переменных, потом проверяется, что исходные данные не изменились, и обновляются значения разделяемых переменных. 
Если оказывается, что исходные данные изменились, то работа повторяется.
```java
do {
  Integer current = v.getValue();
  Integer updated = current + 5;
} while (v.compareAndSet(current, updated))
```

Оптимистического подхода придерживаются `Atomic` классы и `StampedLock`.

### Пессимистический
В пессимистическом подходе при выполнении любой операции блокируется весь объект целиком. 
Равнозначно `synchronized(this)`.

Блокировка может осуществляться с помощью [замков](locks.md).


---
## ThreadLocal

Для того чтобы ограничить область видимости различных нитей, был придуман класс `ThreadLocal`. 
Он позволяет обращаться в различных потоках с, казалось бы, одним и тем же полем.

Класс представляет собой контейнер, содержащий внутри себя поле, которое должно принимать различные значения для различных нитей. 
Т.к. это контейнер, класс является обобщенным тем типом, который он в себе хранит.

Первоначально класс предназначался для наследования, чаще всего с помощью анонимного класса. При этом начальное значение хранимого объекта устанавливалось с помощью переопределяемого метода `initalValue()`, который по умолчанию возвращает null. Пример такого переопределения приведен ниже
```java
private static final ThreadLocal<Date> threadLocalDate = new ThreadLocal() {
    @Override
    protected Date initialValue() {
        return new Date(); //Класс Date здесь приведен как пример потоконебезопасного класса
    }
}
```

Но с появлением в Java 8 функций предпочтительнее создавать экземпляр класса с помощью статического метода генерации `withInitial()`, принимающего лямбду:
```java
//Каждая нить, пришедшая сюда, будет инициализировать этот объект по-своему
private static final ThreadLocal<Date> threadLocalDate = ThreadLocal.withInitial(() -> new Date());
```

Получать значения из контейнера можно с помощью обычного `get()`, а обновлять хранимое значение с помощью обычного `set()`.

Внутри каждого потока есть мапа `ThreadLocalMap`, в которой лежат состояния объектов для этого потока.
В мапе ключом является ссылка на объект `ThreadLocal`, а значением - искомое значение для данного потока.
Интересно, что в качестве реализации мапы используется не `HashMap`, а самописная хэш-таблица с открытой адресацией с помощью [linear probing](../../data_structures/hashtable.md).
Т.е. реализация `ThreadLocal` чисто JDK-шная и не имеет никакой нативной магии.

### Применение
Можно сказать, что `ThreadLocal` это синглтон для потока.

`ThreadLocal` используется:
- Для потоконебезопасных объектов, которые можно сгенерить для каждого потока. Например `SimpleDateFormatter` или jdbc `Connection`. Но сейчас так уже никто не делает, т.к. у этих классов есть потокобезопасные обертки или аналоги.
- В инфраструктурных задачах:
  - В [MDC](../../external_lib/slf4j.md) для хранения ключей логирования, ассоциированных с потоком
  - Метрики по потокам

В web-приложениях `ThreadLocal` может использоваться нитями, которые обрабатывают входящие запросы. 
Но вместо этого рекомендуется использовать объекты, который будут ассоциированы с запросом, а не с потоком.
Например, в Spring - это [бины со скоупом](../../spring/beans.md) `request`.

В скором времени в Java планирует появиться класс `ScopedValue`, который должен будет заменить `ThreadLocal`.
К тому же он будет корректно работать с зелеными потоками.


---
## К изучению
- [ ] javadoc на `java.util.concurrent`
- [X] [Курс по многопоточности в Java](https://fillthegaps.getcourse.ru/mt7)
- [X] Исходный код класса `ThreadLocal`
- [ ] https://metanit.com/java/tutorial/8.9.php
- [ ] Про ThreadLocal: https://articles.javatalks.ru/articles/17