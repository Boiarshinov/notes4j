---
title: "Akka Persistence"
tags:
  - akka
  - database
draft: false
---

# Akka Persistence

**Akka Persistence** - это один из модулей фреймворка Akka, позволяющий восстанавливать состояние акторов из БД при каких-либо отказах (например, выходе из строя ноды).

Akka Persistence основан на методологии Event Sourcing.
Персистентные акторы работают с тремя основными типами сущностей - командами и ивентами.
- `Command` - сообщения, которые может получать актор от других акторов
- `Event` - события, которые сохраняются в БД
- `State` - состояние актора, которое можно восстановить, переиграв события. Чаще всего состояние делают иммутабельным, чтобы проще было отслеживать точки его изменения.

Состояние актора должно описываться с помощью совокупности событий, которые с ним произошли.
Таким образом, возможно восстановить состояние актора прогнав все события, связанные с ним в том порядке, в котором они происходили.


## Persistence Actor

Каждый персистентный актор должен наследоваться от `EventSourcedBehaviour` и типизироваться конкретными видами команд, ивентов и состояния.

Каждый актор должен иметь уникальный `persistenceId`, который будет использоваться в качестве ключа при хранении в БД.
По этому ключу затем можно будет вычитать ивенты, и проиграв их, восстановить состояние актора.
Идентификатор должен быть типом `PersistenceId`, в котором предусмотрены различные удобные методы генерации из строк.
Часто используется составной формат идентификатора: `<type hint>|<entity id>`.

Основные методы, которые должны быть реализованы в персистентном акторе:
- `commandHandler()` - описываются действия при приходе различных комманд в формате `команда -> лямбда`. Билдер хэндлера позволяет фильтровать прием различных команд в зависимости от текущего состояния актора.
- `eventHandler()` - описывается процессинг различных ивентов в формате `ивент -> лямбда`
- `emptyState()` - начальное состояние актора, в котором он стартует
- `signalHandler()` - здесь задаются сайд эффекты, которые необходимо выполнить после восстановления актора
- `tagsFor()` - можно задать теги для различных событий. Тэги будут так же сохраняться в БД.

### Обработка команд
Обработка каждой команды должна заканчиваться сохранением в БД ивента.
Для этого используется класс `Effect`.
Обработка команды как правило заканчивается созданием ивента и его сохранением:
```java
var event = new MyEvent(someArgs);
return new Effect().persist(event);
```

Гарантируется, что пока ивент не будет сохранен в БД, актор не начнет обрабатывать новые команды. Пришедшие команды помещаются в стеш (in-memory) до того момента, как актор закончит сохранение ивента в БД.

При обработке некоторых команд может отсутствовать необходимость изменения состояния актора и соответственно сохранения ивентов в БД.
В этих случаях обработка команды заканчивается передачей специального null-object: `new Effect().none()`.

После сохранения ивента в базу могут быть выполнены какие-то сайд эффекты с помощью метода `thenRun()`:
```java
return new Effect().persist(event)
    .thenRun(state -> doSideEffects(state));
```

Сайд эффекты исполняются с гарантией at most once.


### Обработка ивентов
После того как ивент сохранен в БД, ивент поступает в метод `eventHandler()`, где должно произойти обновление состояния актора.
При обработке ивента не должны вызываться какие-либо сайд эффекты.
Потому что иначе они будут вызваны при восстановлении состояния актора.

При переподнятии актора для восстановления состояния актора используется тот же самый метод.

### Работа с состоянием
В простых случаях актор может не менять свое поведение.
Если же актор сложный и необходимо ограничивать некоторое поведение в зависимости от текущего состояния, то можно сделать `State` интерфейсом, от которого будет наследоваться несколько различных классов, каждый из которых будет определять возможное поведение.
Затем в `commandHandler()` можно будет разбить обработку команд на различные виды состояний:
```java
new CommandHandlerBuilder()
    .forStateType(StateOne.class)
        .onCommand(DoOne.class, this::onDoOne)

    .forStateType(StateTwo.class)
        .onCommand(DoTwo.class, this::onDoTwo)
        .onCommand(DoThree.class, this::onDoThree)
    
    .forAnyState()
        .onAnyCommand(state, command -> new Effect().unhandled())

    .build();
```


---
## К изучению
- [ ] [Официальная документация](https://doc.akka.io/docs/akka/current/typed/persistence.html)