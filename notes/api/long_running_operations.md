---
title: "Long-running operations"
tags:
  - api
  - rest
draft: false
---

# Длительные операции

Некоторые эндпойнты при вызове могут требовать длительной работы на стороне сервера.
Например, обработка видео или изображений, долгие агрегирующие запросы к базе данных, вызов внешних систем и т.д.
Также иногда сервис, предоставляющий API, может зависеть от других сервисов, имеющих не такие строгие SLA. 

В таких случаях обычные синхронные запросы не очень хорошо подходят.
Они не позволяют контролировать процесс выполнения длительной работы: не дают информации о том, какая часть работы выполнена на конкретный момент времени, не позволяют отменить процесс, чтобы сервер не занимался работой впустую.

Для реализации длительных операций используется паттерн фьючеров (промисов) - аналог [`CompletableFuture`](../java/multithreading/completable_future.md) из Java.
Смысл в том, чтобы как можно быстрее отдать клиенту ответ с идентификатором операции, по которому он потом сможет запрашивать статус ее исполнения с помощью отдельного метода.
```uml
@startuml

participant client as client
participant server as server

client -> server: POST do long running operation
server --> client: operationId
server -> server: do operation
client -> server: GET operation status
server --> client: status

@enduml
```

Есть различные подходы к тому, как клиенту узнать о завершении операции:
- polling - клиент периодически запрашивает статус операции
- long-polling - клиент открывает соединение, а сервер вернет результат только по завершению операции
- webhook - сервер вызовет адресата вебхука по завершению операции

Здесь рассматривается вариант с поллингом.

Операция может находится в одном из трех (четырех) состояний:
- в процессе
- успешно завершена
- завершена с ошибкой
- (опционально) отменена

Для каждого из состояний должен быть некоторый свой вид ответа.
```java
@GetMapping("operations/{operationId}")
<R extends Result, M> Operation<R, M> getTaskStatus(@PathVariable String operationId) {
    /* ... */
}

record Operation<R extends Result, M>(
    String id,
    Status status,
    R result, //Может быть как успешный ответ, так и данные об ошибке
    M metadata //метаданные выполнения операции: количество обработанных файлов, ожидаемое время окончания и т.д.
) {}

enum Status {
    IN_PROGRESS,
    COMPLETE,
    ERROR
}

interface Result {}

// Ошибку нужно возвращать отдельной структурой, чтобы отличать ошибки выполнения операции от ошибок вызова API.
record OperationError(
    String code,
    String message,
    Object details
) implements Result {}
```

Не все клиенты API имеют возможность прихранить у себя `operationId` на время выполнения операции. 
Поэтому должен быть также доступен метод запроса всех операций, запущенных клиентом.

Под запросы статуса длительных операций можно выделять отдельный ресурс в системе, а можно сделать как подресурс к сущности.
```
GET /operations/{operationId}

GET /resource/process/{operationId}
```

Вариант с подресурсом начинает плохо работать, когда у сущности есть сабсущности:
```
GET /resource/{id}/subEntity/process/{operationId}
```
В таком случае уже нельзя будет запросить список всех операций по сущности верхнего уровня.


---
## Галя, у нас отмена!

Для некоторых видов операций у пользователя API должна быть возможность отменить операцию.
Например, если он допустил ошибку во входных данных, или если результат исполнения ему уже не нужен, или если операция выполняется дольше, чем он ожидал.

Для отмены можно завести свой подресурс:
```
POST /operations/{operationId}/cancel
```

А можно использовать метод DELETE
```
DELETE /operations/{operationId}
```

При отмене желательно, чтобы все промежуточные эффекты, произошедшие во время исполнения операции, были откачены.
Например, созданные файлы удалены, транзакции в БД откачены и т.д.
Если сервер не может откатить процесс самостоятельно, он должен дать клиенту информацию, необходимую для ручного отката.


---
## Установка на паузу

Некоторые операции должны иметь возможность установки на паузу и возобновления.
Далеко не все операции могут иметь такую возможность.

Для установки на паузу в API заводят отдельные ресурсы:
```
POST /operations/{operationId}/pause
POST /operations/{operationId}/resume
```
Так например сделано в REST API [Kafka Connect](../tools/kafka_connect.md). 

При этом в ответе на запрос статуса необходимо показать состояние процесса.
Поле `status` при этом лучше не трогать, пускай он все так же будет иметь значение `IN_PROGRESS`.
Можно добавить флажок паузы в метаданные:
```java
record PausableMetadata(
    boolean running
) implements Metadata {}
```


---
## Жизненный цикл операций

Как правило операция как сущность нужна до своего окончания и немного после, чтобы клиент успел запросить результат операции.
Поэтому необходимо установить политику хранения данных об операциях:
- хранить вечно
- удалять по TTL

Если у операции есть TTL, то стоит указать в ответе на запрос статуса дату/время удаления информации об операции:
```java
record Operation<R extends Result, M>(
    String id,
    Status status,
    Instant expireAt,
    R result, //Может быть как успешный ответ, так и данные об ошибке
    M metadata //метаданные выполнения операции: количество обработанных файлов, ожидаемое время окончания и т.д.
) {}
```

---
## К изучению
- [X] Книга "Паттерны проектирования API". Глава 10