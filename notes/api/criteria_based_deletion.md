---
title: "Criteria-based deletion"
tags:
  - api
  - rest
draft: false
---

# Удаление на основе критерия

В некоторых продуктах может возникать потребность в массовом удалении ресурсов по определенному признаку.
[Пакетное удаление](./batch_operations.md) в данном случае плохо подходит, т.к. требует указания идентификаторов удаляемых ресурсов.
А чтобы получить идентификаторы ресурсов, имеющих определенный признак, потребуется сначала запросить их с помощью [стандартного метода](./standard_methods.md) List.


### Атомарность
Последовательный вызов List и BatchDelete не обеспечивает атомарности выполнения.
Отсутствие атомарности может приводить к странным результатам.

Например, вы хотите удалить с доски в Miro все желтые стикеры (возможно дурацкий пример, но его легко визуализировать).
Вы делаете запрос List с фильтром по желтым стикерам и получаете идентификаторы всех желтых стикеров.
В это время второй пользователь доски Miro создал новый желтый стикер.
А третий пользователь поменял цвет одного из желтых стикеров на зеленый.
После этого вы вызываете BatchDelete и в итоге у вас удаляются все желтые стикеры кроме одного, и удаляется один зеленый стикер.
Такое поведение вряд ли можно назвать ожидаемым.

Поэтому операцию удаления по определенному признаку лучше проводить одним вызовом API.
Нам требуется новый [кастомный метод](./custom_methods.md).


### Большая сила влечёт большую ответственность
В случае с двумя последовательными вызовами List и BatchDelete клиент мог оценить объем изменений по результату вызова метода List.
Возможно, увидев количество удаляемых данных, клиент осознает, что неправильно составил фильтр, т.к. List вернул слишком много или наоборот слишком мало записей.
Поэтому в атомарном методе удаления по критерию нужно тоже дать клиенту возможность оценить объем удаляемых данных.

Решение этой проблемы: добавить в запрос удаления флажок, который будет указывать действительно мы удаляем данные, или пока только тренируемся.
```
POST /desk/{deskId}/stickers/purge
{
    "filter": {
        "color": "yellow"
    },
    "force": false
}

{
    "purgeCount": 100
}
```

```uml
@startuml

participant client as client
participant server as server

client -> server: Estimate purge. force=false
server --> client: Estimation: purgeCount=100
client -> client: Do I want to delete all of this?
client -> server: Do purge. force=true
server --> client: Complete: purgeCount=100

@enduml
```

__Q__: Почему бы клиенту не делать сначала запрос списка по фильтру вместо Purge с force=false? 
Ведь у нас там может быть параметр `sizeEstimation`, по которому тоже можно оценить объем удаляемых данных. 

__A__: Такой вариант тоже возможен, но в этом случае клиенту API придется самому догадываться о двух-фазном удалении.
API метода удалению по критерию никак не подскажет клиенту, что можно предварительно запросить объем удаления данных с помощью метода List.
К тому же в ответе метода List может и не быть параметра `sizeEstimation`, но при этом будет возвращаться множество ненужных для желаемой операции данных.

> Мы с помощью дизайна API побуждаем клиентов создать определенный UX. 
> Если нашим клиентом является фронтэнд, то возможно при попытке удаления по признаку он выведет диалоговое окно с вопросом: Будут удалены 100500 файлов, вы хотите продолжить?


### Формат ответа
Так как в фильтре могут быть переданы любые значения, то и объем удаляемых данных может быть любым.
Например, могут быть удалены абсолютно все ресурсы выбранного типа.
Удаление большой части ресурсов вряд ли может быть выполнен достаточно быстро, в процессе ожидания клиент может не дождаться ответа и отвалиться по таймауту.
Поэтому ответ на метод Purge лучше делать в виде [длительной операции](./long_running_operations.md).

```json
{
    "operationId": "abc123",
    "status": "COMPLETE",
    "result" {
        "purgeCount": 100
    }
}
```


---
## К изучению
- [X] Книга "Паттерны проектирования API". Глава 19
- [X] Google [AIP-165 Criteria-based delete](https://google.aip.dev/165)
