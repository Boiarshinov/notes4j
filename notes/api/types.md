---
title: "Types in API"
tags:
  - api
draft: false
---

# Types in API

С помощью API между собой могут общаться сервисы, написанные на совершенно разных языках программирования.
Поэтому в API не должны использоваться специфические типы данных.
Чтобы стандартизировать различные типы данных в API, так чтобы они одинаково сериализовывались и десериализовывались в разных языках программирования были придуманы различные [форматы представления данных](../formats/formats.md).
В API часто используются форматы:
- [JSON](../formats/json.md)
- [XML](../formats/xml.md)
- [Protobuf](../formats/protobuf.md)


---
## null или отсутствие данных

> Различать между собой null и отсутствие данных. Описывать разницу в документации на API.

> В документации на API явно указывать, какое значение примет поле, если его не задать.


---
## Булевы значения

> Пореже использовать булевы типы. Возможно лучше подойдут перечисления или битовые маски.
API имеет тенденцию развиваться и разрастаться, при этом булевы поля начинают множиться.
Допустим у сущности было два статуса: открыт и закрыт, и для описания статуса использовалось поле `isOpen`.
Затем статусная модель начала разрастаться и появился еще один статус: в процессе.
Приходится добавить еще одно поле `isInProgress`.
В итоге появляется два булева поля, которые могут вступать друг с другом в конфликт, которые необходимо валидировать на инварианты.
Поэтому лучше в таком случае использовать перечисления `status = inProgress` или битовые маски, если свойства могут применяться совместно.

> В названии поля булевого типа не стоит использовать отрицание.
Лучше назвать поле `isActive`, чем `isUnactive`, т.к. при обработке поля может использоваться инверсия, а мозгу тяжело обработать двойное отрицание.

> Поле желательно называть так, чтобы значение `false` приводило к happy path
Если сущность может быть в двух состояниях: активна и заблокирована, то лучше назвать поле `isBlocked`, чем `isActive`.
В большинстве языков значением по умолчанию для булевых полей является `false`.
Если пользователь не укажет значение поля `isBlocked`, то ему будет присвоено значение `false`, что правильно, т.к. вряд ли мы хотим, чтобы по умолчанию сущность была заблокирована.

Эта рекомендация может вступать в противоречие с предыдущей.
В таком случае лучше в первую очередь прислушаться к данной рекомендации


---
## Числа

> Использовать числа, когда поле подразумевает возможность провести арифметическую операцию.
Над полями `count`, `sizeKB`, `weightKg`, `sizePx` имеет смысл проводить арифметические операции, поэтому в API их лучше задавать числовыми типами.
Но бывают такие числовые поля, над которыми арифметические действия не подразумеваются, и потому их лучше представить в виде строк.
Например, значение времени лучше задать в виде строчки `2024-04-01T15:16:00.000Z`, чем в виде timestamp в Unix-time.
Битовую маску лучше представить в виде массива строковых значений, чем в виде числа.


> В документации на API определять верхнюю и нижнюю границы допустимых значений числового поля.
В разных языках могут использоваться разные типы данных для чисел разной размерности.
Как правило существуют 8-битные, 32-битные и 64-битные типы данных.
Но не везде, например в python нет 64-битного типа, вместо этого используется безразмерный тип, занимающий в памяти от 34 до бесконечности бит.
Разработчикам необходимо понимать какой тип данных в своем языке использовать для поля, а понять это можно, зная границы допустимых значений.

> Если поле необязательное, то возможно лучше использовать строковый тип данных, т.к. не во всех языках примитивы могут принимать значение null.

Открытые вопросы:
- как лучше передавать числа с плавающей точкой? Не лучше ли использовать строки?


---
## Строки
Самый универсальный тип данных. 
В строку можно запихнуть и текст, и числа, и даже бинарные данные, закодировав их, например, в [Base64](../formats/base64.md).

> В документации на API указывать ограничения на размер строки.
Клиентам API придется как-то работать с этими строками, возможно хранить их, надо дать им возможность оценить объем хранимых и передаваемых данных.

> Следует использовать кодировку UTF-8 и проверять нормализацию символов.
UTF-8 де-факто стандарт для представления строк в форматах JSON и XML.
К сожалению, UTF-8 позволяет представить один и тот же символ разными способами. 
Например `a с крышечкой` может быть описан как отдельный символ, так и комбинация `a` и `крышечка`.
Поэтому в XML специально используется нормализация таких символов.


---
## Перечисления

> Не использовать порядковый номер перечисления в качестве значения поля.


---
## Списки / массивы

> Элементы списка должны быть одного типа.

> В документации на API указывать ограничения на размер массива. 

> Если элементов в массиве может быть очень много, то лучше использовать пагинацию.

> Не заданный массив воспринимать как пустой массив.


---
## Мапы

> В качестве ключей использовать строки
