---
title: "Types in API"
tags:
  - api
draft: false
---

# Types in API

С помощью API между собой могут общаться сервисы, написанные на совершенно разных языках программирования.
Поэтому в API не должны использоваться специфические типы данных.
Чтобы стандартизировать различные типы данных в API, так чтобы они одинаково сериализовывались и десериализовывались в разных языках программирования были придуманы различные [форматы представления данных](../formats/formats.md).
В API часто используются форматы:
- [JSON](../formats/json.md)
- [XML](../formats/xml.md)
- [Protobuf](../formats/protobuf.md)


---
## null или отсутствие данных

> Различать между собой null и отсутствие данных. Описывать разницу в документации на API.

> В документации на API явно указывать, какое значение примет поле, если его не задать.


---
## Булевы значения

> Пореже использовать булевы типы. Возможно лучше подойдут перечисления или битовые маски.

API имеет тенденцию развиваться и разрастаться, при этом булевы поля начинают множиться.
Допустим у сущности было два статуса: открыт и закрыт, и для описания статуса использовалось поле `isOpen`.
Затем статусная модель начала разрастаться и появился еще один статус: в процессе.
Приходится добавить еще одно поле `isInProgress`.
В итоге появляется два булева поля, которые могут вступать друг с другом в конфликт, которые необходимо валидировать на инварианты.
Поэтому лучше в таком случае использовать перечисления `status = inProgress` или битовые маски, если свойства могут применяться совместно.


> В названии поля булевого типа не стоит использовать отрицание.

Лучше назвать поле `isActive`, чем `isUnactive`, т.к. при обработке поля может использоваться инверсия, а мозгу тяжело обработать двойное отрицание.


> Поле желательно называть так, чтобы значение `false` приводило к happy path

Если сущность может быть в двух состояниях: активна и заблокирована, то лучше назвать поле `isBlocked`, чем `isActive`.
В большинстве языков значением по умолчанию для булевых полей является `false`.
Если пользователь не укажет значение поля `isBlocked`, то ему будет присвоено значение `false`, что правильно, т.к. вряд ли мы хотим, чтобы по умолчанию сущность была заблокирована.

Эта рекомендация может вступать в противоречие с предыдущей.
В таком случае лучше в первую очередь прислушаться к данной рекомендации


---
## Числа

> Использовать числа, когда поле подразумевает возможность провести арифметическую операцию.

Над полями `count`, `sizeKB`, `weightKg`, `sizePx` имеет смысл проводить арифметические операции, поэтому в API их лучше задавать числовыми типами.
Но бывают такие числовые поля, над которыми арифметические действия не подразумеваются, и потому их лучше представить в виде строк.
Например, значение времени лучше задать в виде строчки `2024-04-01T15:16:00.000Z`, чем в виде timestamp в Unix-time.
Битовую маску лучше представить в виде массива строковых значений, чем в виде числа.


> В документации на API определять верхнюю и нижнюю границы допустимых значений числового поля.

В разных языках могут использоваться разные типы данных для чисел разной размерности.
Как правило существуют 8-битные, 32-битные и 64-битные типы данных.
Но не везде, например в python нет 64-битного типа, вместо этого используется безразмерный тип, занимающий в памяти от 34 до бесконечности бит.
Разработчикам необходимо понимать какой тип данных в своем языке использовать для поля, а понять это можно, зная границы допустимых значений.

> Если поле необязательное, то возможно лучше использовать строковый тип данных, т.к. не во всех языках примитивы могут принимать значение null.

Открытые вопросы:
- как лучше передавать числа с плавающей точкой? Не лучше ли использовать строки?


---
## Строки
Самый универсальный тип данных. 
В строку можно запихнуть и текст, и числа, и даже бинарные данные, закодировав их, например, в [Base64](../formats/base64.md).

> В документации на API указывать ограничения на размер строки.

Клиентам API придется как-то работать с этими строками, возможно хранить их, надо дать им возможность оценить объем хранимых и передаваемых данных.


> Следует использовать кодировку UTF-8 и проверять нормализацию символов.

UTF-8 де-факто стандарт для представления строк в форматах JSON и XML.
К сожалению, UTF-8 позволяет представить один и тот же символ разными способами. 
Например `a с крышечкой` может быть описан как отдельный символ, так и комбинация `a` и `крышечка`.
Поэтому в XML специально используется нормализация таких символов.


---
## Перечисления

> Не использовать порядковый номер перечисления в качестве значения поля. Вместо этого использовать наименование перечисления или вообще перейти на строковый тип.

Это вообще максимальный антипаттерн.
Мало того, что порядковый номер плохо отражает суть данных, так еще такой подход ограничивает развитие API.
В какой-то момент на стороне поставщика может добавиться значение перечисления не в конец списка, а в середину.
Тогда все порядковые номера сдвинутся и все клиенты сломаются.


> На стороне клиента не завязываться на ограниченное количество значений перечислений. Надо быть готовым обработать неожиданное значение.

Пример из жизни: как-то раз я интегрировался с Google ReCaptcha, в документации на нее было указано, что в случае непрохождения проверки возвращается причина отказа.
Возможные значения причины отказа были перечислены в документации и я реализовал на стороне своего приложение поле причины отказа с помощью перечисления.
Но во время интеграционного тестирования выяснилось, что это поле может принимать незадокументированные значения и мой код падал при десериализации.
Решением явилось добавление еще одного значения в перечисление - `UNEXPECTED`, в которое я десериализовывал все неизвестные значения.
Еще одним возможным решением было бы перевести поле в строковый тип, но мне нужно было организовать логику обработки ответа в зависимости от известных вариантов ответа, поэтому хотелось остаться на типобезопасных перечислениях.

Подробно о примере с ReCaptcha можно почитать [тут](https://github.com/Boiarshinov/enums/blob/master/docs/effective_enums.md#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC-%D0%BF%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B9).

---
## Списки / массивы

> Элементы списка должны быть одного типа.

Элементы массива разного типа могут быть весьма неожиданными для потребителя API.
В языках со статической типизацией это может приводить к исключениям, а в языках с динамической - к неожиданному поведению.


> В документации на API указывать ограничения на размер массива.

> Если элементов в массиве может быть очень много, то лучше использовать пагинацию.

> Не заданный массив воспринимать как пустой массив.


---
## Мапы

> В качестве ключей использовать строки


---
## К изучению
- [X] Книга "Паттерны проектирования API". Глава 5
