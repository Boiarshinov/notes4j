---
title: "Pagination"
tags:
  - api
  - rest
draft: false
---

# Пагинация

Пагинация - это разделение списка элементов на страницы с указанным количеством элементов. 
Пагинация используется в тех случаях, когда количество запрашиваемых элементов слишком велико, а их единовременный запрос может привести к большим нагрузкам на сеть / базу.

В основе пагинации лежит разделение всего множества элементов на отдельные группы, называемые страницами. 
На каждой странице находится строго определенное количество элементов.

Интерфейс, демонстрирующий такую идею, используется во многих интернет-магазинах.

Тренд последних лет - использование бесконечной ленты вместо номерных страниц.
Обусловлен этот тренд не модой, а увеличением объема данных в системах, увеличивающимся временем ответа на запрос данных для страниц в середине и конце списка в традиционном представлении страниц.


## Размер страницы

> Даже если страница не является последней, нужно заложить в описание API, что в ней может вернуться меньше элементов, чем максимальный размер страницы.

Такое может случиться, когда не всю фильтрацию можно провести на уровне базы данных.
Например, сервер API направил запрос в базу данных с фильтрацией по какому-то полю и лимитом в 10 записей.
Но в процессе подготовки ответа выяснилось, что у пользователя ограничен доступ к записям определенной группы, или что часть записей относятся к другому ресурсу, который внесен в черный список.
Может быть множество других причин, по которым приходится отбрасывать часть записей после извлечения их из базы данных.
В результате мы вернем клиенту только 8 записей, хотя максимальный размер страницы - 10.

Клиенты должны быть готовы и к тому, что в странице вернется 0 записей, но при этом будет ссылка на следующую страницу.


> У размера страницы должно быть значение по умолчанию

Значение размера по умолчанию стоит выбирать исходя из производительности системы и размера данных.
Если система может относительно быстро вернуть 100 записей размером в несколько килобайт, то почему бы не установить дефолтный размер страницы в 100.
Но если размер одной записи слишком большой, например сотни килобайт, а пропускная способность канала составляет 100 Мбит/с, то стоит уменьшить размер страницы например до 10, чтобы ответ мог быть получен за приемлемые для человека единицы секунд.

В тех случаях, когда мы не знаем средний объем данных у ресурсов, можно не присваивать значение по умолчанию и сделать размер страницы обязательным полем.
Такое может быть, к примеру, если ресурсами являются файлы, которые сам же пользователь и вгрузил.
Например, если наша система - это файловая помойка вроде Яндекс Диска.
И в выборке могут быть как маленькие текстовые файлы, так и медиа-файлы: фотографии или даже огромные видео.


> У размера страницы должен быть верхний предел

Вряд ли стоит давать пользователю за один запрос выгрузить всю базу.
Поэтому стоит ограничить размер страницы сверху.
Но бросать ошибку при этом не обязательно, т.к. мы уже предупредили клиента (см. раздел выше), что в возвращаемой странице может быть меньше результатов, чем он указал.
Даже если страница не последняя.


---
## Указатель страницы

> Указатель на следующую страницу должен быть непонятным.

Способ организации пагинации на бэкенде может быть очень разным в зависимости от используемой системы хранения.

Желательно указатель на следующую страницу получать таким образом:
1. Определяем, что в нашем случае будет определять сдвиг по списку элементов. Это может быть идентификатор последней записи на текущей странице, таймстемп, оффсет в кафке и так далее.
2. Хэшируем его на секретном ключе. Ключ можно обновлять с некоторой периодичностью.
3. Конвертируем хэш в [Base64 url-encoding](../formats/base64.md), чтобы указатель можно было использовать в параметрах URI.

__Q__: Как обеспечить бесшовность изменения секретного ключа?
Ведь при смене значения ключа, у всех клиентов протухнут указатели, что может быть раздражающим, если ты находился в середине коллекции.

__A__: ???


> Значение null указателя означает, что мы долистали до конца.

Как рассматривалось выше, в странице может вернуться меньше элементов, чем запрашивалось, и это абсолютно нормально.
В том числе может вернуться ноль элементов.
Поэтому, чтобы явно показать клиенту, что больше страниц нет, нужно вернуть `null` в указателе на следующую страницу.


> Клиент должен быть готов, что на странице будут результаты выдачи, которые он уже видел на предыдущих страницах.

Между запросами двух страниц в системе могут быть добавлены новые ресурсы, удалены старые и так далее, что в итоге приведет к сдвигу результатов.
И те элементы, которые раньше были последними на странице 15, могут переехать на страницу 16.


---
## Итоговый вид API

```
GET /resources?pageToken={pageToken}&pageSize=50

{
    "results": [],
    "nextPageToken": "atf7h8="
}
```


---
## К изучению
- [X] Книга "Паттерны проектирования API". Глава 21
- [ ] Google [AIP-158 Pagination](https://google.aip.dev/158)
- [ ] [Доклад Сазоновых про производительность пагинации на Postgres](https://youtu.be/wi6h9ox1wwM?si=iKsfJNcYQau_FqKL). Youtube 45:35
